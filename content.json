{"meta":{"title":"Bondi_blue","subtitle":"","description":"Colin的个人博客","author":"Colin Jin","url":"localhost:4000","root":"/"},"pages":[{"title":"关于","date":"2019-11-28T15:20:24.596Z","updated":"2019-11-28T15:20:24.590Z","comments":true,"path":"about/index.html","permalink":"about/index.html","excerpt":"","text":"我是个快乐的小码农，现从事于iOS开发工作，喜欢美剧和各种风格的纯音乐。 关于主题本站主题是：Material X 与主题相关的疑问请前去主题文档页面查询或者留言，谢谢！ 关于友链友链页：https://xaoxuu.com/friends/ 想添加友链的朋友请将本站主页 https://xaoxuu.com 添加到贵站的友链中，然后在我的友链页留言，我看到后会及时添加（只限非盈利性网站）。 One More Thing懒加载占位图如果喜欢请拿去：图片链接 欢迎灌水"},{"title":"所有分类","date":"2019-11-28T03:41:13.627Z","updated":"2019-11-28T03:41:13.627Z","comments":true,"path":"categories/index.html","permalink":"categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-11-28T03:55:55.764Z","updated":"2019-11-28T03:55:55.758Z","comments":true,"path":"tags/index.html","permalink":"tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2018-10-23T01:33:09.000Z","updated":"2019-11-28T11:48:41.392Z","comments":true,"path":"friends/index.html","permalink":"friends/index.html","excerpt":"","text":""},{"title":"404 Not Found","date":"2019-11-28T04:14:20.999Z","updated":"2019-11-28T04:14:20.999Z","comments":true,"path":"404.html","permalink":"404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"}],"posts":[{"title":"iOS多线程知识梳理","slug":"iOS 多线程知识梳理","date":"2019-10-18T02:12:40.000Z","updated":"2019-10-21T07:13:20.000Z","comments":true,"path":"2019/10/18/iOS 多线程知识梳理/","link":"","permalink":"2019/10/18/iOS 多线程知识梳理/","excerpt":"","text":"进程、线程与队列进程与线程 进程是系统中正在运行的一个应用程序，每个进程之间是独立的，每个进程均运行在专用且受保护的内存空间内 线程是进程的基本执行单元，一个进程中的任务都在线程中执行，所以一个进程由至少一个线程组成 多线程一个线程中的任务是串行的，同一时间内，一个线程只能执行一个任务。 一个进程可以开启多条线程，每条线程可以并行执行不同的任务。同一时间，CPU只能处理一条线程，多线程并发执行是CPU快速地在多条线程之间调度 iOS的多线程技术有：pthread、NSThread、GCD、NSOperation 主线程主线程主要负责显示和刷新UI界面，处理UI事件 队列的类型 主队列：dispatch_get_main_queue 全局并发队列：dispatch_get_global_queue 自己创建队列：dispatch_queue_create 线程通信GCD: 1dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;2 &#x2F;&#x2F; 在这里执行耗时操作3 dispatch_async(dispatch_get_main_queue(), ^&#123;4 &#x2F;&#x2F; 回到主线程，执行UI刷新操作5 &#125;);6&#125;); NSOperationQueue: 1[[NSOperationQueue new] addOperationWithBlock:^&#123;2 NSLog(@&quot;子线程下载: %@&quot;, NSOperationQueue.currentQueue);3 [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;4 NSLog(@&quot;主线程刷新UI: %@&quot;, NSOperationQueue.currentQueue);5 &#125;];6&#125;]; 死锁死锁就是队列引起的循环等待：在串行队列A中向队列A添加一个同步任务，例如主队列同步： 1- (void)viewDidLoad &#123;2 [super viewDidLoad];3 dispatch_sync(dispatch_get_main_queue(), ^&#123; &#x2F;&#x2F; 👈死锁在这一行4 &#x2F;&#x2F; NSLog(@&quot;在主队列同步执行&quot;);5 &#125;);6&#125; 或者在自定义线程中： 1&#x2F;&#x2F; NOT OK2- (void)test1 &#123;3 NSLog(@&quot;在主线程添加一个串行队列queue&quot;);4 dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);5 dispatch_async(queue, ^&#123;6 NSLog(@&quot;在串行队列queue中添加一个同步任务&quot;);7 dispatch_sync(queue, ^&#123; &#x2F;&#x2F; 👈死锁在这一行8 NSLog(@&quot;OK&quot;);9 &#125;);10 &#125;);11&#125;1213&#x2F;&#x2F; 这样就不会死锁了14- (void)test2 &#123;15 NSLog(@&quot;在主线程添加一个串行队列queue&quot;);16 dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);17 dispatch_queue_t queue2 &#x3D; dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);18 dispatch_async(queue, ^&#123;19 NSLog(@&quot;在串行队列queue2中添加一个同步任务&quot;);20 dispatch_sync(queue2, ^&#123;21 NSLog(@&quot;OK&quot;);22 &#125;);23 &#125;);24&#125; 线程管理设置最大并发数NSOperationQueue： 1- (void)setMaxConcurrentOperationCount:(NSInteger)cnt; 设置依赖1NSOperationQueue *queue &#x3D; [[NSOperationQueue alloc] init];2NSOperation *op1 &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;3 sleep(1);4 NSLog(@&quot;下载图片1&quot;);5&#125;];6NSOperation *op2 &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;7 sleep(1);8 NSLog(@&quot;下载图片2&quot;);9&#125;];10NSOperation *combine &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;11 NSLog(@&quot;合成图片&quot;);12&#125;];13[combine addDependency:op1];14[combine addDependency:op2];1516[queue addOperation:op1];17[queue addOperation:op2];18[queue addOperation:combine]; 设置栅栏若干个网络请求结束后执行下一步操作： 1dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);2dispatch_group_t group &#x3D; dispatch_group_create();3for (int i &#x3D; 0; i &lt; 10; i++) &#123;4 dispatch_group_async(group, queue, ^&#123;5 sleep(1);6 NSLog(@&quot;网络请求 ---- %d&quot;,i);7 &#125;);8&#125;9dispatch_barrier_sync(queue, ^&#123;10 NSLog(@&quot;主线程刷新UI&quot;);11&#125;); 通过NSOperationQueue实现： 1NSOperationQueue *queue &#x3D; [[NSOperationQueue alloc] init];2for (int i &#x3D; 0; i &lt; 10; i++) &#123;3 NSOperation *op &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;4 sleep(1);5 NSLog(@&quot;网络请求 ---- %d&quot;,i);6 &#125;];7 [queue addOperation:op];8&#125;9[queue addBarrierBlock:^&#123;10 NSLog(@&quot;刷新页面&quot;);11&#125;]; 线程组在n个耗时并发任务都完成后，再去执行接下来的任务。比如，在n个网络请求完成后去刷新UI页面 1dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);2dispatch_group_t group &#x3D; dispatch_group_create();3for (int i &#x3D; 0; i &lt; 10; i++) &#123;4 dispatch_group_async(group, queue, ^&#123;5 NSLog(@&quot;网络请求 ---- %d&quot;,i);6 &#125;);7&#125;8dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;9 NSLog(@&quot;刷新页面&quot;);10&#125;); GCD和NSOperation有什么区别 GCD是纯C语言的API；NSOperation是基于GCD的OC版本封装 GCD只支持FIFO的队列；NSOperation可以很方便地调整执行顺序，设置最大并发数量 NSOperationQueue可以轻松在operation间设置依赖关系，而GCD需要些很多代码才能实现 NSOperationQueue支持KVO，可以检测operation是否正在执行(isExecuted)，是否结束(isFinish),是否取消(isCancel) GCD的执行速度比NSOperation快","categories":[],"tags":[{"name":"多线程","slug":"多线程","permalink":"tags/多线程/"}]},{"title":"SwiftUI实践Demo","slug":"SwiftUI学习笔记及实践","date":"2019-10-17T02:12:40.000Z","updated":"2019-10-21T07:13:20.000Z","comments":true,"path":"2019/10/17/SwiftUI学习笔记及实践/","link":"","permalink":"2019/10/17/SwiftUI学习笔记及实践/","excerpt":"","text":"SwiftUI入门学习实践Apple Developer SwiftUI 一、SwiftUI是什么？1. 定义：SwiftUI是苹果在 “WWDC-2019” 推出的一款全新的 “声明式UI” 框架。 拆开看，Swift + UI，即基于Swift语言基础语法的UI框架 2. 特点： “简洁迅速”的Swift：越来越简洁的Swift语法，配上Swift迅速的优势 “即视”的UI：降低调试成本，一边写code、一边就可实时预览查看UI界面 跨平台：一套代码，即可完成iOS、iPadOS、macOS、watchOS的开发与适配 “声明式”编程： 对比之前的 “指令式”编程，我们通常需要告诉计算机“怎么做”？ 而“声明式”编程是让我们告诉计算机 “做什么”？（至于最底层怎么做，开发者无需关心） 举个例子，对于写UI而言， 指令式编程：就是，怎么画？ 把每个frame、layout等等统统需要计算到位 声明式编程：就是，画什么？ 把想要的效果描述出来，其他都交给框架去做 3. 开发环境：这么新的技术肯定需要环境的支持。SwiftUI所需要的开发环境，如下： Xcode：Xcode 11.1+ MacOS：MacOS 10.15+ iOS：iOS 13+ PS：由于SwiftUI只能应用与iOS 13系统以上的设备。 因此，这项技术不建议用在需要适配低版本（iOS 13 以下）的App上。 不过如果是无需适配低版本的新项目，或者学习者全可以上手“玩一玩”。 毕竟苹果的新技术还是很有意思的嘛~ 二、SwiftUI的基本组件（语法） 这块知识比较“基础”且“重要”。只有记住了这些基本组件，才能用较少的代码开发出精美的App 下面是一些重要的SwiftUI组件： 组件介绍 名称 含义 Text 用来显示文本的组件，类似UIKit中的UILabel Image 用来展示图片的组件，类似UIKit中的UIImageView Button 用于可点击的按钮组件，类似UIKit中的UIButton List 用来展示列表的组件，类似UIKit中的UITableView ScrollView 用来支持滑动的组件，类似UIKit中的UIScrollView Spacer 一个灵活的空间，用来填充空白的组件 Divider 一条分割线，用来划分区域的组件 VStack 将子视图按“竖直方向”排列布局。（Vertical stack） HStack 将子视图按“水平方向”排列布局。（Horizontal stack） ZStack 将子视图按“两轴方向均对齐”布局（居中，有重叠效果） 基本组件 Text：用来显示文本的组件，类似UIKit中的UILabel 1Text(\"Hello, we are QiShare!\").foregroundColor(.blue).font(.system(size: 32.0))2复制代码 Image：用来展示图片的组件，类似UIKit中的UIImageView 1Image.init(systemName: \"star.fill\").foregroundColor(.yellow)2复制代码 Button：用于可点击的按钮组件，类似UIKit中的UIButton 1Button(action: &#123; self.showingProfile.toggle() &#125;) &#123;2 Image(systemName: \"paperplane.fill\")3 .imageScale(.large)4 .accessibility(label: Text(\"Right\"))5 .padding()6&#125;7复制代码 List：用来展示列表的组件，类似UIKit中的UITableView 1List(0..&lt;5)&#123;_ in2 NavigationLink.init(destination: VStack(alignment:.center)&#123;3 Image.init(systemName: \"\\(item+1).square.fill\").foregroundColor(.green)4 Text(\"详情界面\\(item + 1)\").font(.system(size: 16))5 &#125;) &#123;6 //ListRow7 &#125; ScrollView：用来支持滑动的组件，类似UIKit中的UIScrollView Spacer：一个灵活的空间，用来填充空白的组件 Divider：一条分割线，用来划分区域的组件 布局组件 VStack：将子视图按“Y轴竖直方向”布局（Vertical stack） HStack：将子视图按“X轴水平方向”布局（Horizontal stack） ZStack：将子视图按“XY两轴方向均对齐”布局 功能组件 NavigationView：负责App中导航功能的组件，类似UIKit中的UINavigationView NavigationLink：负责App页面跳转的组件，类似于UINavigationView中的push与pop功能 1NavigationView &#123;2 List(0..&lt;5)&#123;_ in3 NavigationLink.init(destination: VStack(alignment:.center)&#123;4 Image.init(systemName: \"\\(item+1).square.fill\").foregroundColor(.green)5 Text(\"详情界面\\(item + 1)\").font(.system(size: 16))6 &#125;) &#123;7 //ListRow8 &#125;9&#125;10.navigationBarTitle(\"导航\\(item)\",displayMode: .inline) TabView：负责App中的标签页功能的组件，类似UIKit中的UITabBarController 1TabView &#123;2 Text(\"The First Tab\")3 .tabItem &#123;4 Image(systemName: \"1.square.fill\")5 Text(\"First\")6 &#125;7 Text(\"Another Tab\")8 .tabItem &#123;9 Image(systemName: \"2.square.fill\")10 Text(\"Second\")11 &#125;12 Text(\"The Last Tab\")13 .tabItem &#123;14 Image(systemName: \"3.square.fill\")15 Text(\"Third\")16 &#125;17&#125;18.font(.headline) 三、SwiftUI快速上手实践下面来快速实现一个有TabView、NavigationView、List的简单示例Demo SF Symbols 是从 iOS 13 和 macOS 10.15 开始内置于系统中的字符图标库，它提供了上千种常见的线条图标，而且我们可以任意地为它们设置尺寸，颜色等属性。Apple 甚至准备了专门的app：SF Symbols 来帮助你查看可用的符号： 接下来就让我们用这些Symbols制作个小Demo ContentView.swift： 1import SwiftUI23struct ContentView: View &#123;4 5 @State var isLeftNav = false6 @State var isRightNav = false7 8 init() &#123;9 //修改导航栏文字颜色10 UINavigationBar.appearance().largeTitleTextAttributes = [.foregroundColor: UIColor.systemBlue]11 UINavigationBar.appearance().titleTextAttributes = [.foregroundColor: UIColor.systemBlue]12 UINavigationBar.appearance().tintColor = .systemBlue13 &#125;14 15 var body: some View &#123;16 TabView &#123;17 18 // Tab1:19 NavigationView &#123;20 List(Symbols, id:\\.self) &#123;21 ListRow(symbol: $0)22 &#125;23 .navigationBarTitle(Text(\"SF Symbols\"))24 .navigationBarItems(leading: leftNavButton, trailing: rightNavButton)25 &#125;.tabItem &#123;26 Image.init(systemName: \"star.fill\")27 Text(\"Tab1\").font(.subheadline)28 &#125;29 30 // Tab2:31 NavigationView &#123;32 Text(\"This is the second tab.\")33 &#125;.tabItem &#123;34 Image.init(systemName: \"star.fill\")35 Text(\"Tab2\").font(.subheadline)36 &#125;37 &#125;38 &#125;39 40 var leftNavButton: some View &#123;41 Button(action: &#123; self.isLeftNav.toggle() &#125;) &#123;42 Image(systemName: \"person.crop.circle\")43 .imageScale(.large)44 .accessibility(label: Text(\"Left\"))45 .padding()46 &#125;47 .sheet(isPresented: $isLeftNav) &#123;48 VStack &#123;49 Text(\"Hello, we are QiShare!\").foregroundColor(.blue).font(.system(size: 32.0))5051 HStack &#123;52 Spacer()53 Spacer()54 Text(\"an iOS Team. \").fontWeight(.black).foregroundColor(.purple)55 Spacer()56 Text(\"We are learning SwiftUI.\").foregroundColor(.blue)57 Spacer()58 &#125;59 &#125;60 &#125;61 &#125;62 63 var rightNavButton: some View &#123;64 Button(action: &#123; self.isRightNav.toggle() &#125;) &#123;65 Image(systemName: \"paperplane.fill\")66 .imageScale(.large)67 .accessibility(label: Text(\"Right\"))68 .padding()69 &#125;70 .sheet(isPresented: $isRightNav, onDismiss: &#123;71 print(\"dissmiss RrightNav\")72 &#125;) &#123;73 ZStack &#123;74 Text(\"This is the Right Navi Button.\")75 &#125;76 &#125;77 &#125;78&#125; ListRow.swift：List对应的Cell 1struct ListRow: View &#123;2 var symbol: String3 var body: some View &#123;4 NavigationLink(destination: ListDetail(symbol: symbol)) &#123;5 6 HStack &#123;7 //图片8 Image(systemName: symbol)9 .resizable()10 .frame(width: 60, height: 60)11 .foregroundColor(Colors.randomElement())12 //分割13 Divider()14 Spacer()15 //文字16 Text(symbol)17 Spacer()18 &#125;19 &#125;20 &#125;21&#125; ListDetail.swift： 1import SwiftUI23struct ListDetail: View &#123;4 5 var symbol: String6 7 var body: some View &#123;8 VStack &#123;9 10 Text(\"Image:\").font(.headline)11 12 Spacer()13 14 Image(systemName: symbol)15 .foregroundColor(Colors.randomElement())16 .imageScale(.large)17 .scaleEffect(3)18 .padding(.bottom, 100)19 20 Divider()21 22 Text(\"Image Name:\").font(.headline)23 Spacer()24 Text(symbol)25 .font(.largeTitle)26 Spacer()27 &#125;28 .navigationBarTitle(symbol)29 &#125;30&#125; 源码：本文Demo","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"categories/SwiftUI/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"tags/SwiftUI/"}]},{"title":"iOS底层原理总结 - 探寻OC对象的本质","slug":"iOS底层原理总结 - 探寻OC对象的本质","date":"2018-07-17T01:08:40.000Z","updated":"2018-07-18T06:11:20.000Z","comments":true,"path":"2018/07/17/iOS底层原理总结 - 探寻OC对象的本质/","link":"","permalink":"2018/07/17/iOS底层原理总结 - 探寻OC对象的本质/","excerpt":"","text":"转载自：iOS底层原理总结 对小码哥底层班视频学习的总结与记录。面试题部分，通过对面试题的分析探索问题的本质内容。 面试题：一个NSObject对象占用多少内存？ 探寻OC对象的本质，我们平时编写的Objective-C代码，底层实现其实都是C\\C++代码。 OC的对象结构都是通过基础C\\C++的结构体实现的。我们通过创建OC文件及对象，并将OC文件转化为C++文件来探寻OC对象的本质 OC如下代码 1#import &lt;Foundation/Foundation.h&gt;23int main(int argc, const char * argv[]) &#123;4 @autoreleasepool &#123;5 NSObject *objc = [[NSObject alloc] init];6 NSLog(@\"Hello, World!\");7 &#125;8 return 0;9&#125; 我们通过命令行将OC的mian.m文件转化为c++文件。 1clang -rewrite-objc main.m -o main.cpp // 这种方式没有指定架构例如arm64架构 其中cpp代表（c plus plus）2生成 main.cpp 我们可以指定架构模式的命令行，使用xcode工具 xcrun 1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp 2生成 main-arm64.cpp main-arm64.cpp 文件中搜索NSObjcet，可以找到NSObjcet_IMPL（IMPL代表 implementation 实现） 我们看一下NSObject_IMPL内部 1struct NSObject_IMPL &#123;2 Class isa;3&#125;;4// 查看Class本质5typedef struct objc_class *Class;6//我们发现Class其实就是一个指针，对象底层实现其实就是这个样子。 思考： 一个OC对象在内存中是如何布局的。 NSObjcet的底层实现，点击NSObjcet进入发现NSObject的内部实现 1@interface NSObject &lt;NSObject&gt; &#123;2#pragma clang diagnostic push3#pragma clang diagnostic ignored \"-Wobjc-interface-ivars\"4 Class isa OBJC_ISA_AVAILABILITY;5#pragma clang diagnostic pop6&#125;7@end 转化为c语言其实就是一个结构体 1struct NSObject_IMPL &#123;2 Class isa;3&#125;; 那么这个结构体占多大的内存空间呢，我们发现这个结构体只有一个成员，isa指针，而指针在64位架构中占8个字节。也就是说一个NSObjec对象所占用的内存是8个字节。到这里我们已经可以基本解答第一个问题。但是我们发现NSObject对象中还有很多方法，那这些方法不占用内存空间吗？其实类的方法等也占用内存空间，但是这些方法所占用的存储空间并不在NSObject对象中。 为了探寻OC对象在内存中如何体现，我们来看下面一段代码 1NSObject *objc = [[NSObject alloc] init]; 上面一段代码在内存中如何体现的呢？ 上述一段代码中系统为NSObject对象分配8个字节的内存空间，用来存放一个成员isa指针。 那么isa指针这个变量的地址就是结构体的地址，也就是NSObjcet对象的地址。 假设isa的地址为0x100400110，那么上述代码分配存储空间给NSObject对象，然后将存储空间的地址赋值给objc指针。 objc存储的就是isa的地址 objc指向内存中NSObject对象地址，即指向内存中的结构体，也就是isa的位置。 自定义类的内部实现1@interface Student : NSObject&#123;2 3 @public4 int _no;5 int _age;6&#125;7@end8@implementation Student910int main(int argc, const char * argv[]) &#123;11 @autoreleasepool &#123;1213 Student *stu = [[Student alloc] init];14 stu -&gt; _no = 4;15 stu -&gt; _age = 5;16 17 NSLog(@\"%@\",stu);18 &#125;19 return 0;20&#125;21@end 按照上述步骤同样生成c++文件。并查找Student，我们发现Student_IMPL 1struct Student_IMPL &#123;2 struct NSObject_IMPL NSObject_IVARS;3 int _no;4 int _age;5&#125;; 发现第一个是 NSObject_IMPL的实现。而通过上面的实验我们知道NSObject_IMPL内部其实就是Class isa 那么我们假设 struct NSObject_IMPL NSObject_IVARS; 等价于 Class isa; 可以将上述代码转化为 1struct Student_IMPL &#123;2 Class *isa;3 int _no;4 int _age;5&#125;; 因此此结构体占用多少存储空间，对象就占用多少存储空间。因此结构体占用的存储空间为，isa指针8个字节空间+int类型_no4个字节空间+int类型_age4个字节空间共16个字节空间 1Student *stu = [[Student alloc] init];2stu -&gt; _no = 4;3stu -&gt; _age = 5; 那么上述代码实际上在内存中的体现为，创建Student对象首先会分配16个字节，存储3个东西，isa指针8个字节，4个字节的_no ,4个字节的_age image.png sutdent对象的3个变量分别有自己的地址。而stu指向isa指针的地址。因此stu的地址为0x100400110，stu对象在内存中占用16个字节的空间。并且经过赋值，_no里面存储4 ，_age里面存储5 验证Student在内存中模样 1struct Student_IMPL &#123;2 Class isa;3 int _no;4 int _age;5&#125;;67@interface Student : NSObject8&#123;9 @public10 int _no;11 int _age;12&#125;13@end1415@implementation Student1617int main(int argc, const char * argv[]) &#123;18 @autoreleasepool &#123;19 // 强制转化20 struct Student_IMPL *stuImpl = (__bridge struct Student_IMPL *)stu;21 NSLog(@\"_no = %d, _age = %d\", stuImpl-&gt;_no, stuImpl-&gt;_age); // 打印出 _no = 4, _age = 522 &#125;23 return 0;24&#125; 上述代码将oc对象强转成Student_IMPL的结构体。也就是说把一个指向oc对象的指针，指向这种结构体。由于我们之前猜想，对象在内存中的布局与结构体在内存中的布局相同，那么如果可以转化成功，说明我们的猜想正确。由此说明stu这个对象指向的内存确实是一个结构体。 实际上想要获取对象占用内存的大小，可以通过更便捷的运行时方法来获取。 1class_getInstanceSize([Student class])2NSLog(@\"%zd,%zd\", class_getInstanceSize([NSObject class]) ,class_getInstanceSize([Student class]));3// 打印信息 8和16 窥探内存结构实时查看内存数据 方式一：通过打断点。 Debug Workflow -&gt; viewMemory address中输入stu的地址 image 从上图中，我们可以发现读取数据从高位数据开始读，查看前16位字节，每四个字节读出的数据为 16进制 0x0000004(4字节) 0x0000005(4字节) isa的地址为 00D1081000001119(8字节) 方式二：通过lldb指令xcode自带的调试器 1memory read 0x10074c4502// 简写 x 0x10074c45034// 增加读取条件5// memory read/数量格式字节数 内存地址6// 简写 x/数量格式字节数 内存地址7// 格式 x是16进制，f是浮点，d是10进制8// 字节大小 b：byte 1字节，h：half word 2字节，w：word 4字节，g：giant word 8字节910示例：x/4xw // /后面表示如何读取数据 w表示4个字节4个字节读取，x表示以16进制的方式读取数据，4则表示读取4次 同时也可以通过lldb修改内存中的值 1memory write 0x100400c68 62将_no的值改为了6 image 那么一个NSObject对象占用多少内存？ NSObjcet实际上是只有一个名为isa的指针的结构体，因此占用一个指针变量所占用的内存空间大小，如果64bit占用8个字节，如果32bit占用4个字节。 更复杂的继承关系 面试题：在64bit环境下， 下面代码的输出内容？ 1/* Person */2@interface Person : NSObject3&#123;4 int _age;5&#125;6@end78@implementation Person9@end1011/* Student */12@interface Student : Person13&#123;14 int _no;15&#125;16@end1718@implementation Student19@end2021int main(int argc, const char * argv[]) &#123;22 @autoreleasepool &#123;2324 NSLog(@\"%zd %zd\",25 class_getInstanceSize([Person class]),26 class_getInstanceSize([Student class])27 );28 &#125;29 return 0;30&#125; 这道面试题的实质是想问一个Person对象，一个Student对象分别占用多少内存空间？ 我们依据上面的分析与发现，类对象实质上是以结构体的形式存储在内存中，画出真正的内存图例 image 我们发现只要是继承自NSObject的对象，那么底层结构体内一定有一个isa指针。 那么他们所占的内存空间是多少呢？单纯的将指针和成员变量所占的内存相加即可吗？上述代码实际打印的内容是16 16，也就是说，person对象和student对象所占用的内存空间都为16个字节。 其实实际上person对象确实只使用了12个字节。但是因为内存对齐的原因。使person对象也占用16个字节。 编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能是该基本数据类型的整倍的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为对齐模数。 为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。 我们可以总结内存对齐为两个原则： 原则 1. 前面的地址必须是后面的地址正数倍,不是就补齐。 原则 2. 整个Struct的地址必须是最大字节的整数倍。 通过上述内存对齐的原则我们来看，person对象的第一个地址要存放isa指针需要8个字节，第二个地址要存放_age成员变量需要4个字节，根据原则一，8是4的整数倍，符合原则一，不需要补齐。然后检查原则2，目前person对象共占据12个字节的内存，不是最大字节数8个字节的整数倍，所以需要补齐4个字节，因此person对象就占用16个字节空间。 而对于student对象，我们知道sutdent对象中，包含person对象的结构体实现，和一个int类型的_no成员变量，同样isa指针8个字节，_age成员变量4个字节，_no成员变量4个字节，刚好满足原则1和原则2，所以student对象占据的内存空间也是16个字节。 OC对象的分类 面试题：OC的类信息存放在哪里。 面试题：对象的isa指针指向哪里。 示例代码 1#import &lt;Foundation/Foundation.h&gt;2#import &lt;objc/runtime.h&gt;34/* Person */ 5@interface Person : NSObject &lt;NSCopying&gt;6&#123;7 @public8 int _age;9&#125;10@property (nonatomic, assign) int height;11- (void)personMethod;12+ (void)personClassMethod;13@end1415@implementation Person16- (void)personMethod &#123;&#125;17+ (void)personClassMethod &#123;&#125;18@end1920/* Student */21@interface Student : Person &lt;NSCoding&gt;22&#123;23 @public24 int _no;25&#125;26@property (nonatomic, assign) int score;27- (void)studentMethod;28+ (void)studentClassMethod;29@end3031@implementation Student32- (void)studentMethod &#123;&#125;33+ (void)studentClassMethod &#123;&#125;34@end3536int main(int argc, const char * argv[]) &#123;37 @autoreleasepool &#123; 38 NSObject *object1 = [[NSObject alloc] init];39 NSObject *object2 = [[NSObject alloc] init];4041 Student *stu = [[Student alloc] init];42 [Student load];4344 Person *p1 = [[Person alloc] init];45 p1-&gt;_age = 10;46 [p1 personMethod];47 [Person personClassMethod];48 Person *p2 = [[Person alloc] init];49 p2-&gt;_age = 20;50 &#125;51 return 0;52&#125; OC的类信息存放在哪里 OC对象主要可以分为三种 instance对象（实例对象） class对象（类对象） meta-class对象（元类对象） instance对象就是通过类alloc出来的对象，每次调用alloc都会产生新的instance对象 1NSObjcet *object1 = [[NSObjcet alloc] init];2NSObjcet *object2 = [[NSObjcet alloc] init]; object1和object2都是NSObject的instace对象（实例对象），但他们是不同的两个对象，并且分别占据着两块不同的内存。 instance对象在内存中存储的信息包括 isa指针 其他成员变量 image 衍生问题：在上图实例对象中根本没有看到方法，那么实例对象的方法的代码放在什么地方呢？那么类的方法的信息，协议的信息，属性的信息都存放在什么地方呢？ class对象 我们通过class方法或runtime方法得到一个class对象。class对象也就是类对象 1Class objectClass1 = [object1 class];2Class objectClass2 = [object2 class];3Class objectClass3 = [NSObject class];45// runtime6Class objectClass4 = object_getClass(object1);7Class objectClass5 = object_getClass(object2);8NSLog(@\"%p %p %p %p %p\", objectClass1, objectClass2, objectClass3, objectClass4, objectClass5); 每一个类在内存中有且只有一个class对象。可以通过打印内存地址证明 class对象在内存中存储的信息主要包括 isa指针 superclass指针 类的属性信息（@property），类的成员变量信息（ivar） 类的对象方法信息（instance method），类的协议信息（protocol） image 成员变量的值时存储在实例对象中的，因为只有当我们创建实例对象的时候才为成员变赋值。但是成员变量叫什么名字，是什么类型，只需要有一份就可以了。所以存储在class对象中。 类方法放在那里？ 元类对象 meta-class 1//runtime中传入类对象此时得到的就是元类对象2Class objectMetaClass = object_getClass([NSObject class]);3// 而调用类对象的class方法时得到还是类对象，无论调用多少次都是类对象4Class cls = [[NSObject class] class];5Class objectClass3 = [NSObject class];6class_isMetaClass(objectMetaClass) // 判断该对象是否为元类对象7NSLog(@\"%p %p %p\", objectMetaClass, objectClass3, cls); // 后面两个地址相同，说明多次调用class得到的还是类对象 每个类在内存中有且只有一个meta-class对象。 meta-class对象和class对象的内存结构是一样的，但是用途不一样，在内存中存储的信息主要包括 isa指针 superclass指针 类的类方法的信息（class method） image meta-class对象和class对象的内存结构是一样的，所以meta-class中也有类的属性信息，类的对象方法信息等成员变量，但是其中的值可能是空的。 对象的isa指针指向哪里 当对象调用实例方法的时候，我们上面讲到，实例方法信息是存储在class类对象中的，那么要想找到实例方法，就必须找到class类对象，那么此时isa的作用就来了。 1[stu studentMethod]; instance的isa指向class，当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现进行调用。 当类对象调用类方法的时候，同上，类方法是存储在meta-class元类对象中的。那么要找到类方法，就需要找到meta-class元类对象，而class类对象的isa指针就指向元类对象 1[Student studentClassMethod]; class的isa指向meta-class 当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用 image 当对象调用其父类对象方法的时候，又是怎么找到父类对象方法的呢？，此时就需要使用到class类对象superclass指针。 1[stu personMethod];2[stu init]; 当Student的instance对象要调用Person的对象方法时，会先通过isa找到Student的class，然后通过superclass找到Person的class，最后找到对象方法的实现进行调用，同样如果Person发现自己没有响应的对象方法，又会通过Person的superclass指针找到NSObject的class对象，去寻找响应的方法 image 当类对象调用父类的类方法时，就需要先通过isa指针找到meta-class，然后通过superclass去寻找响应的方法 1[Student personClassMethod];2[Student load]; 当Student的class要调用Person的类方法时，会先通过isa找到Student的meta-class，然后通过superclass找到Person的meta-class，最后找到类方法的实现进行调用 最后又是这张静定的isa指向图，经过上面的分析我们在来看这张图，就显得清晰明了很多。 image 对isa、superclass总结 instance的isa指向class class的isa指向meta-class meta-class的isa指向基类的meta-class，基类的isa指向自己 class的superclass指向父类的class，如果没有父类，superclass指针为nil meta-class的superclass指向父类的meta-class，基类的meta-class的superclass指向基类的class instance调用对象方法的轨迹，isa找到class，方法不存在，就通过superclass找父类 class调用类方法的轨迹，isa找meta-class，方法不存在，就通过superclass找父类 如何证明isa指针的指向真的如上面所说？我们通过如下代码证明： 1NSObject *object = [[NSObject alloc] init];2Class objectClass = [NSObject class];3Class objectMetaClass = object_getClass([NSObject class]);45NSLog(@\"%p %p %p\", object, objectClass, objectMetaClass); 打断点并通过控制台打印相应对象的isa指针 image 我们发现object-&gt;isa与objectClass的地址不同，这是因为从64bit开始，isa需要进行一次位运算，才能计算出真实地址。而位运算的值我们可以通过下载objc源代码找到。 image 我们通过位运算进行验证。 image 我们发现，object-isa指针地址0x001dffff96537141经过同0x00007ffffffffff8位运算，得出objectClass的地址0x00007fff96537140 接着我们来验证class对象的isa指针是否同样需要位运算计算出meta-class对象的地址。 当我们以同样的方式打印objectClass-&gt;isa指针时，发现无法打印 image 同时也发现左边objectClass对象中并没有isa指针。我们来到Class内部看一下 1typedef struct objc_class *Class;23struct objc_class &#123;4 Class _Nonnull isa OBJC_ISA_AVAILABILITY;56#if !__OBJC2__7 Class _Nullable super_class OBJC2_UNAVAILABLE;8 const char * _Nonnull name OBJC2_UNAVAILABLE;9 long version OBJC2_UNAVAILABLE;10 long info OBJC2_UNAVAILABLE;11 long instance_size OBJC2_UNAVAILABLE;12 struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE;13 struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE;14 struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE;15 struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;16#endif1718&#125; OBJC2_UNAVAILABLE;19/* Use `Class` instead of `struct objc_class *` */ 相信了解过isa指针的同学对objc_class结构体内的内容很熟悉了，今天这里不深入研究，我们只看第一个对象是一个isa指针，为了拿到isa指针的地址，我们自己创建一个同样的结构体并通过强制转化拿到isa指针。 1struct xx_cc_objc_class&#123;2 Class isa;3&#125;;45Class objectClass = [NSObject class];6struct xx_cc_objc_class *objectClass2 = (__bridge struct xx_cc_objc_class *)(objectClass); 此时我们重新验证一下 image 确实，objectClass2的isa指针经过位运算之后的地址是meta-class的地址。 本文面试题总结： 一个NSObject对象占用多少内存？ 答：一个指针变量所占用的大小（64bit占8个字节，32bit占4个字节） 对象的isa指针指向哪里？ 答：instance对象的isa指针指向class对象，class对象的isa指针指向meta-class对象，meta-class对象的isa指针指向基类的meta-class对象，基类自己的isa指针也指向自己。 OC的类信息存放在哪里？ 答：成员变量的具体值存放在instance对象。对象方法，协议，属性，成员变量信息存放在class对象。类方法信息存放在meta-class对象。 底层原理相关文章：iOS底层原理总结 - 文集","categories":[{"name":"iOS","slug":"iOS","permalink":"categories/iOS/"}],"tags":[{"name":"OC","slug":"OC","permalink":"tags/OC/"}]}]}