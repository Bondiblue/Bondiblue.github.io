{"meta":{"title":"Bondi_blue","subtitle":"","description":"Colin的个人博客","author":"Colin Jin","url":"https://bondiblue.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-11-28T04:14:20.999Z","updated":"2019-11-28T04:14:20.999Z","comments":true,"path":"404.html","permalink":"https://bondiblue.github.io/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"tags","date":"2019-11-28T03:55:55.764Z","updated":"2019-11-28T03:55:55.758Z","comments":true,"path":"tags/index.html","permalink":"https://bondiblue.github.io/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-11-28T03:41:13.627Z","updated":"2019-11-28T03:41:13.627Z","comments":true,"path":"categories/index.html","permalink":"https://bondiblue.github.io/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2018-10-23T01:33:09.000Z","updated":"2019-11-28T11:48:41.392Z","comments":true,"path":"friends/index.html","permalink":"https://bondiblue.github.io/friends/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-11-28T15:20:24.596Z","updated":"2019-11-28T15:20:24.590Z","comments":true,"path":"about/index.html","permalink":"https://bondiblue.github.io/about/index.html","excerpt":"","text":"我是个快乐的小码农，现从事于iOS开发工作，喜欢美剧和各种风格的纯音乐。 关于主题本站主题是：Material X 与主题相关的疑问请前去主题文档页面查询或者留言，谢谢！ 关于友链友链页：https://xaoxuu.com/friends/ 想添加友链的朋友请将本站主页 https://xaoxuu.com 添加到贵站的友链中，然后在我的友链页留言，我看到后会及时添加（只限非盈利性网站）。 One More Thing懒加载占位图如果喜欢请拿去：图片链接 欢迎灌水"}],"posts":[{"title":"iOS多线程知识梳理","slug":"iOS 多线程知识梳理","date":"2019-10-18T02:12:40.000Z","updated":"2019-10-21T07:13:20.000Z","comments":true,"path":"2019/10/18/iOS 多线程知识梳理/","link":"","permalink":"https://bondiblue.github.io/2019/10/18/iOS%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/","excerpt":"","text":"进程、线程与队列进程与线程 进程是系统中正在运行的一个应用程序，每个进程之间是独立的，每个进程均运行在专用且受保护的内存空间内 线程是进程的基本执行单元，一个进程中的任务都在线程中执行，所以一个进程由至少一个线程组成 多线程一个线程中的任务是串行的，同一时间内，一个线程只能执行一个任务。 一个进程可以开启多条线程，每条线程可以并行执行不同的任务。同一时间，CPU只能处理一条线程，多线程并发执行是CPU快速地在多条线程之间调度 iOS的多线程技术有：pthread、NSThread、GCD、NSOperation 主线程主线程主要负责显示和刷新UI界面，处理UI事件 队列的类型 主队列：dispatch_get_main_queue 全局并发队列：dispatch_get_global_queue 自己创建队列：dispatch_queue_create 线程通信GCD: 1dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;2 &#x2F;&#x2F; 在这里执行耗时操作3 dispatch_async(dispatch_get_main_queue(), ^&#123;4 &#x2F;&#x2F; 回到主线程，执行UI刷新操作5 &#125;);6&#125;); NSOperationQueue: 1[[NSOperationQueue new] addOperationWithBlock:^&#123;2 NSLog(@&quot;子线程下载: %@&quot;, NSOperationQueue.currentQueue);3 [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;4 NSLog(@&quot;主线程刷新UI: %@&quot;, NSOperationQueue.currentQueue);5 &#125;];6&#125;]; 死锁死锁就是队列引起的循环等待：在串行队列A中向队列A添加一个同步任务，例如主队列同步： 1- (void)viewDidLoad &#123;2 [super viewDidLoad];3 dispatch_sync(dispatch_get_main_queue(), ^&#123; &#x2F;&#x2F; 👈死锁在这一行4 &#x2F;&#x2F; NSLog(@&quot;在主队列同步执行&quot;);5 &#125;);6&#125; 或者在自定义线程中： 1&#x2F;&#x2F; NOT OK2- (void)test1 &#123;3 NSLog(@&quot;在主线程添加一个串行队列queue&quot;);4 dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);5 dispatch_async(queue, ^&#123;6 NSLog(@&quot;在串行队列queue中添加一个同步任务&quot;);7 dispatch_sync(queue, ^&#123; &#x2F;&#x2F; 👈死锁在这一行8 NSLog(@&quot;OK&quot;);9 &#125;);10 &#125;);11&#125;1213&#x2F;&#x2F; 这样就不会死锁了14- (void)test2 &#123;15 NSLog(@&quot;在主线程添加一个串行队列queue&quot;);16 dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);17 dispatch_queue_t queue2 &#x3D; dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);18 dispatch_async(queue, ^&#123;19 NSLog(@&quot;在串行队列queue2中添加一个同步任务&quot;);20 dispatch_sync(queue2, ^&#123;21 NSLog(@&quot;OK&quot;);22 &#125;);23 &#125;);24&#125; 线程管理设置最大并发数NSOperationQueue： 1- (void)setMaxConcurrentOperationCount:(NSInteger)cnt; 设置依赖1NSOperationQueue *queue &#x3D; [[NSOperationQueue alloc] init];2NSOperation *op1 &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;3 sleep(1);4 NSLog(@&quot;下载图片1&quot;);5&#125;];6NSOperation *op2 &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;7 sleep(1);8 NSLog(@&quot;下载图片2&quot;);9&#125;];10NSOperation *combine &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;11 NSLog(@&quot;合成图片&quot;);12&#125;];13[combine addDependency:op1];14[combine addDependency:op2];1516[queue addOperation:op1];17[queue addOperation:op2];18[queue addOperation:combine]; 设置栅栏若干个网络请求结束后执行下一步操作： 1dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);2dispatch_group_t group &#x3D; dispatch_group_create();3for (int i &#x3D; 0; i &lt; 10; i++) &#123;4 dispatch_group_async(group, queue, ^&#123;5 sleep(1);6 NSLog(@&quot;网络请求 ---- %d&quot;,i);7 &#125;);8&#125;9dispatch_barrier_sync(queue, ^&#123;10 NSLog(@&quot;主线程刷新UI&quot;);11&#125;); 通过NSOperationQueue实现： 1NSOperationQueue *queue &#x3D; [[NSOperationQueue alloc] init];2for (int i &#x3D; 0; i &lt; 10; i++) &#123;3 NSOperation *op &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;4 sleep(1);5 NSLog(@&quot;网络请求 ---- %d&quot;,i);6 &#125;];7 [queue addOperation:op];8&#125;9[queue addBarrierBlock:^&#123;10 NSLog(@&quot;刷新页面&quot;);11&#125;]; 线程组在n个耗时并发任务都完成后，再去执行接下来的任务。比如，在n个网络请求完成后去刷新UI页面 1dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);2dispatch_group_t group &#x3D; dispatch_group_create();3for (int i &#x3D; 0; i &lt; 10; i++) &#123;4 dispatch_group_async(group, queue, ^&#123;5 NSLog(@&quot;网络请求 ---- %d&quot;,i);6 &#125;);7&#125;8dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;9 NSLog(@&quot;刷新页面&quot;);10&#125;); GCD和NSOperation有什么区别 GCD是纯C语言的API；NSOperation是基于GCD的OC版本封装 GCD只支持FIFO的队列；NSOperation可以很方便地调整执行顺序，设置最大并发数量 NSOperationQueue可以轻松在operation间设置依赖关系，而GCD需要些很多代码才能实现 NSOperationQueue支持KVO，可以检测operation是否正在执行(isExecuted)，是否结束(isFinish),是否取消(isCancel) GCD的执行速度比NSOperation快","categories":[],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://bondiblue.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"SwiftUI实践Demo","slug":"SwiftUI学习笔记及实践","date":"2019-10-17T02:12:40.000Z","updated":"2019-10-21T07:13:20.000Z","comments":true,"path":"2019/10/17/SwiftUI学习笔记及实践/","link":"","permalink":"https://bondiblue.github.io/2019/10/17/SwiftUI%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"SwiftUI入门学习实践Apple Developer SwiftUI 一、SwiftUI是什么？1. 定义：SwiftUI是苹果在 “WWDC-2019” 推出的一款全新的 “声明式UI” 框架。 拆开看，Swift + UI，即基于Swift语言基础语法的UI框架 2. 特点： “简洁迅速”的Swift：越来越简洁的Swift语法，配上Swift迅速的优势 “即视”的UI：降低调试成本，一边写code、一边就可实时预览查看UI界面 跨平台：一套代码，即可完成iOS、iPadOS、macOS、watchOS的开发与适配 “声明式”编程： 对比之前的 “指令式”编程，我们通常需要告诉计算机“怎么做”？ 而“声明式”编程是让我们告诉计算机 “做什么”？（至于最底层怎么做，开发者无需关心） 举个例子，对于写UI而言， 指令式编程：就是，怎么画？ 把每个frame、layout等等统统需要计算到位 声明式编程：就是，画什么？ 把想要的效果描述出来，其他都交给框架去做 3. 开发环境：这么新的技术肯定需要环境的支持。SwiftUI所需要的开发环境，如下： Xcode：Xcode 11.1+ MacOS：MacOS 10.15+ iOS：iOS 13+ PS：由于SwiftUI只能应用与iOS 13系统以上的设备。 因此，这项技术不建议用在需要适配低版本（iOS 13 以下）的App上。 不过如果是无需适配低版本的新项目，或者学习者全可以上手“玩一玩”。 毕竟苹果的新技术还是很有意思的嘛~ 二、SwiftUI的基本组件（语法） 这块知识比较“基础”且“重要”。只有记住了这些基本组件，才能用较少的代码开发出精美的App 下面是一些重要的SwiftUI组件： 组件介绍 名称 含义 Text 用来显示文本的组件，类似UIKit中的UILabel Image 用来展示图片的组件，类似UIKit中的UIImageView Button 用于可点击的按钮组件，类似UIKit中的UIButton List 用来展示列表的组件，类似UIKit中的UITableView ScrollView 用来支持滑动的组件，类似UIKit中的UIScrollView Spacer 一个灵活的空间，用来填充空白的组件 Divider 一条分割线，用来划分区域的组件 VStack 将子视图按“竖直方向”排列布局。（Vertical stack） HStack 将子视图按“水平方向”排列布局。（Horizontal stack） ZStack 将子视图按“两轴方向均对齐”布局（居中，有重叠效果） 基本组件 Text：用来显示文本的组件，类似UIKit中的UILabel 1Text(\"Hello, we are QiShare!\").foregroundColor(.blue).font(.system(size: 32.0))2复制代码 Image：用来展示图片的组件，类似UIKit中的UIImageView 1Image.init(systemName: \"star.fill\").foregroundColor(.yellow)2复制代码 Button：用于可点击的按钮组件，类似UIKit中的UIButton 1Button(action: &#123; self.showingProfile.toggle() &#125;) &#123;2 Image(systemName: \"paperplane.fill\")3 .imageScale(.large)4 .accessibility(label: Text(\"Right\"))5 .padding()6&#125;7复制代码 List：用来展示列表的组件，类似UIKit中的UITableView 1List(0..&lt;5)&#123;_ in2 NavigationLink.init(destination: VStack(alignment:.center)&#123;3 Image.init(systemName: \"\\(item+1).square.fill\").foregroundColor(.green)4 Text(\"详情界面\\(item + 1)\").font(.system(size: 16))5 &#125;) &#123;6 //ListRow7 &#125; ScrollView：用来支持滑动的组件，类似UIKit中的UIScrollView Spacer：一个灵活的空间，用来填充空白的组件 Divider：一条分割线，用来划分区域的组件 布局组件 VStack：将子视图按“Y轴竖直方向”布局（Vertical stack） HStack：将子视图按“X轴水平方向”布局（Horizontal stack） ZStack：将子视图按“XY两轴方向均对齐”布局 功能组件 NavigationView：负责App中导航功能的组件，类似UIKit中的UINavigationView NavigationLink：负责App页面跳转的组件，类似于UINavigationView中的push与pop功能 1NavigationView &#123;2 List(0..&lt;5)&#123;_ in3 NavigationLink.init(destination: VStack(alignment:.center)&#123;4 Image.init(systemName: \"\\(item+1).square.fill\").foregroundColor(.green)5 Text(\"详情界面\\(item + 1)\").font(.system(size: 16))6 &#125;) &#123;7 //ListRow8 &#125;9&#125;10.navigationBarTitle(\"导航\\(item)\",displayMode: .inline) TabView：负责App中的标签页功能的组件，类似UIKit中的UITabBarController 1TabView &#123;2 Text(\"The First Tab\")3 .tabItem &#123;4 Image(systemName: \"1.square.fill\")5 Text(\"First\")6 &#125;7 Text(\"Another Tab\")8 .tabItem &#123;9 Image(systemName: \"2.square.fill\")10 Text(\"Second\")11 &#125;12 Text(\"The Last Tab\")13 .tabItem &#123;14 Image(systemName: \"3.square.fill\")15 Text(\"Third\")16 &#125;17&#125;18.font(.headline) 三、SwiftUI快速上手实践下面来快速实现一个有TabView、NavigationView、List的简单示例Demo SF Symbols 是从 iOS 13 和 macOS 10.15 开始内置于系统中的字符图标库，它提供了上千种常见的线条图标，而且我们可以任意地为它们设置尺寸，颜色等属性。Apple 甚至准备了专门的app：SF Symbols 来帮助你查看可用的符号： 接下来就让我们用这些Symbols制作个小Demo ContentView.swift： 1import SwiftUI23struct ContentView: View &#123;4 5 @State var isLeftNav = false6 @State var isRightNav = false7 8 init() &#123;9 //修改导航栏文字颜色10 UINavigationBar.appearance().largeTitleTextAttributes = [.foregroundColor: UIColor.systemBlue]11 UINavigationBar.appearance().titleTextAttributes = [.foregroundColor: UIColor.systemBlue]12 UINavigationBar.appearance().tintColor = .systemBlue13 &#125;14 15 var body: some View &#123;16 TabView &#123;17 18 // Tab1:19 NavigationView &#123;20 List(Symbols, id:\\.self) &#123;21 ListRow(symbol: $0)22 &#125;23 .navigationBarTitle(Text(\"SF Symbols\"))24 .navigationBarItems(leading: leftNavButton, trailing: rightNavButton)25 &#125;.tabItem &#123;26 Image.init(systemName: \"star.fill\")27 Text(\"Tab1\").font(.subheadline)28 &#125;29 30 // Tab2:31 NavigationView &#123;32 Text(\"This is the second tab.\")33 &#125;.tabItem &#123;34 Image.init(systemName: \"star.fill\")35 Text(\"Tab2\").font(.subheadline)36 &#125;37 &#125;38 &#125;39 40 var leftNavButton: some View &#123;41 Button(action: &#123; self.isLeftNav.toggle() &#125;) &#123;42 Image(systemName: \"person.crop.circle\")43 .imageScale(.large)44 .accessibility(label: Text(\"Left\"))45 .padding()46 &#125;47 .sheet(isPresented: $isLeftNav) &#123;48 VStack &#123;49 Text(\"Hello, we are QiShare!\").foregroundColor(.blue).font(.system(size: 32.0))5051 HStack &#123;52 Spacer()53 Spacer()54 Text(\"an iOS Team. \").fontWeight(.black).foregroundColor(.purple)55 Spacer()56 Text(\"We are learning SwiftUI.\").foregroundColor(.blue)57 Spacer()58 &#125;59 &#125;60 &#125;61 &#125;62 63 var rightNavButton: some View &#123;64 Button(action: &#123; self.isRightNav.toggle() &#125;) &#123;65 Image(systemName: \"paperplane.fill\")66 .imageScale(.large)67 .accessibility(label: Text(\"Right\"))68 .padding()69 &#125;70 .sheet(isPresented: $isRightNav, onDismiss: &#123;71 print(\"dissmiss RrightNav\")72 &#125;) &#123;73 ZStack &#123;74 Text(\"This is the Right Navi Button.\")75 &#125;76 &#125;77 &#125;78&#125; ListRow.swift：List对应的Cell 1struct ListRow: View &#123;2 var symbol: String3 var body: some View &#123;4 NavigationLink(destination: ListDetail(symbol: symbol)) &#123;5 6 HStack &#123;7 //图片8 Image(systemName: symbol)9 .resizable()10 .frame(width: 60, height: 60)11 .foregroundColor(Colors.randomElement())12 //分割13 Divider()14 Spacer()15 //文字16 Text(symbol)17 Spacer()18 &#125;19 &#125;20 &#125;21&#125; ListDetail.swift： 1import SwiftUI23struct ListDetail: View &#123;4 5 var symbol: String6 7 var body: some View &#123;8 VStack &#123;9 10 Text(\"Image:\").font(.headline)11 12 Spacer()13 14 Image(systemName: symbol)15 .foregroundColor(Colors.randomElement())16 .imageScale(.large)17 .scaleEffect(3)18 .padding(.bottom, 100)19 20 Divider()21 22 Text(\"Image Name:\").font(.headline)23 Spacer()24 Text(symbol)25 .font(.largeTitle)26 Spacer()27 &#125;28 .navigationBarTitle(symbol)29 &#125;30&#125; 源码：本文Demo","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://bondiblue.github.io/categories/SwiftUI/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://bondiblue.github.io/tags/SwiftUI/"}]},{"title":"如何封装Framework静态库","slug":"如何封装 Framework 静态库","date":"2019-10-13T02:12:40.000Z","updated":"2019-10-13T07:13:20.000Z","comments":true,"path":"2019/10/13/如何封装 Framework 静态库/","link":"","permalink":"https://bondiblue.github.io/2019/10/13/%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%20Framework%20%E9%9D%99%E6%80%81%E5%BA%93/","excerpt":"","text":"工作中使用的第三方SDK基本上都是闭源的，因为公司不能把自己的机密泄露出去。所以当需要给别人提供SDK但不让他们知道代码的实现时就需要封装成静态库 静态库有.a库和.framework库，苹果官方更建议我们使用.framework库，因为其更加强大 .a是一个纯二进制文件，.framework中除了有二进制文件之外还有资源文件.a文件不能直接使用，至少要有.h文件配合，.framework文件可以直接使用.a + .h + sourceFile = .framework 步骤参考这篇博客： iOS开发——创建你自己的Framework 讲解的非常详细 总结一下步骤： 创建工程，最好是起名为xxxDemo例如AXKitDemo，然后新建一个target名为AXKit，并把原来的工程改名为AXKit（为了方便在demo中调试静态库） 新建一个target，选择类型为framework 在framework中创建需要封装的类，写好代码 在Build Setting里更改参数，Math-O Type为Static Library 在Build Phases -&gt; Headers里将需要暴露出来的头文件从Project移动到Public 添加一个Aggregate的target，并添加运行脚本。目的是把编译出来的真机版和模拟器版的framework合并 模拟器编译一下，真机编译一下，然后Aggregate编译一下，然后在项目的Products文件夹里就有了最终生成的静态库 Aggregate的Run Script脚本： 1if [ \"$&#123;ACTION&#125;\" = \"build\" ]2then3INSTALL_DIR=$&#123;SRCROOT&#125;/Products/$&#123;PROJECT_NAME&#125;.framework45DEVICE_DIR=$&#123;BUILD_ROOT&#125;/$&#123;CONFIGURATION&#125;-iphoneos/$&#123;PROJECT_NAME&#125;.framework67SIMULATOR_DIR=$&#123;BUILD_ROOT&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/$&#123;PROJECT_NAME&#125;.framework8910if [ -d \"$&#123;INSTALL_DIR&#125;\" ]11then12rm -rf \"$&#123;INSTALL_DIR&#125;\"13fi1415mkdir -p \"$&#123;INSTALL_DIR&#125;\"1617cp -R \"$&#123;DEVICE_DIR&#125;/\" \"$&#123;INSTALL_DIR&#125;/\"18#ditto \"$&#123;DEVICE_DIR&#125;/Headers\" \"$&#123;INSTALL_DIR&#125;/Headers\"1920lipo -create \"$&#123;DEVICE_DIR&#125;/$&#123;PROJECT_NAME&#125;\" \"$&#123;SIMULATOR_DIR&#125;/$&#123;PROJECT_NAME&#125;\" -output \"$&#123;INSTALL_DIR&#125;/$&#123;PROJECT_NAME&#125;\"2122#open \"$&#123;DEVICE_DIR&#125;\"23#open \"$&#123;SRCROOT&#125;/Products\"24fi","categories":[{"name":"Framework静态库","slug":"Framework静态库","permalink":"https://bondiblue.github.io/categories/Framework%E9%9D%99%E6%80%81%E5%BA%93/"}],"tags":[{"name":"OC","slug":"OC","permalink":"https://bondiblue.github.io/tags/OC/"}]},{"title":"iOS开发主要概念总结","slug":"iOS开发主要概念总结","date":"2019-08-24T02:12:40.000Z","updated":"2019-08-24T07:13:20.000Z","comments":true,"path":"2019/08/24/iOS开发主要概念总结/","link":"","permalink":"https://bondiblue.github.io/2019/08/24/iOS%E5%BC%80%E5%8F%91%E4%B8%BB%E8%A6%81%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/","excerpt":"","text":"一、用什么架构、有什么区别？（MVC、MVVM）1.MVC，即Model-View-Controller 它是苹果公司官方推荐的App开发架构，也是一般开发者最先遇到，最经典的架构。它把整个App分为三个部分：Model负责处理数据；View负责处理UI；Controller是View和Model的桥梁，它将数据从Model层传送到View层并展示出来，同时将View层的交互传到Model层以改变数据。它是应用的一种基本架构，主要目的是将不同的代码归并为不同的模块，做到低耦合、代码分配合理、易于扩展维护。 2.MVVM，MVVM衍生于MVC，是对 MVC 的一种演进，它促进了 UI 代码与业务逻辑的分离 在MVVM 中，view 和 view controller正式联系在一起，我们把它们视为一个组件。view 和 view controller 都不能直接引用model，而是引用视图模型（viewModel）。viewModel 是一个放置用户输入验证逻辑，视图显示逻辑，发起网络请求和其他代码的地方。使用MVVM会轻微的增加代码量，但总体上减少了代码的复杂性。 3.MVVM是MVC的升级版，完全兼容当前的MVC架构 MVVM虽然促进了UI 代码与业务逻辑的分离，一定程度上减轻了ViewController的臃肿度，但是View和ViewModel之间的数据绑定使得 MVVM变得复杂和难用了，如果我们不能更好的驾驭两者之间的数据绑定，同样会造成Controller 代码过于复杂，代码逻辑不易维护的问题。 二、解释一下多线程1.OC中多线程根据封装程度可以分为三个层次：NSThread、GCD和NSOperation 2.NSThread，NSThread是封装程度最小最轻量级的，使用更灵活，但要手动管理线程的生命周期、线程同步和线程加锁等，开销较大 3.GCD(Grand Central Dispatch)，又叫大中央调度，是 Apple 开发的一个多核编程的较新的解决方法 它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。提供了简洁的C语言接口，使用更加简单高效，也是苹果推荐的方式可以自动管理线程的生命周期（创建线程、调度任务、销毁线程）可用于多核的并行运算会自动利用更多的 CPU 内核（比如双核、四核）只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码主要是一些同步执行、异步执行、串行队列、并行队列将”任务”(block)添加到 队列(串行/并发/主队列/全局队列]),并且指定执行任务的函数(同步/异步)一次执行延迟执行 4.NSOperation，NSOperation是一个抽象类，不能直接使用，其目的就是为了定义子类共有的方法和属性 NSOperation、NSOperationQueue 是基于 GCD 更高一层的封装，完全面向对象。但是比 GCD 更简单易用、代码可读性也更高其子类有两个：NSInvocationOperation、NSBlockOperation本质上就是GCD的并发队列，就是异步执行任务 三、RunTime1.Runtime是属于Object-C的底层，是一套比较底层的纯C语言API，属于C语言库 2.在我们平时编写的Object-C代码中, 程序运行过程时, 其实最终都是转成了Runtime的C语言代码, Runtime算是Object-C的幕后工作者 3.静态语言： 如C语言，编译阶段就要决定调用哪个函数，如果函数未实现就会编译报错 动态语言： 如OC语言，编译阶段并不能决定真正调用哪个函数，只要函数声明过即使没有实现也不会报错。OC是一门动态语言，就是因为它总是把一些决定性的工作从编译阶段推迟到运行时阶段。OC代码的运行不仅需要编译器，还需要运行时系统(Runtime Sytem)来执行编译后的代码。 4.Runtime 实际上是一个库，这个库使我们可以在程序运行时动态的创建对象、检查对象，修改类和对象的方法 5.消息（方法）传递、消息转发 6.关联对象(Objective-C Associated Objects)给分类增加属性 7.魔法(Method Swizzling)方法添加和替换 在 Objective-C 的运行时中，每个类有两个方法都会自动调用。+load 是在一个类被初始装载时调用，+initialize 是在应用第一次调用该类的类方法或实例方法前调用的。两个方法都是可选的，并且只有在方法被实现的情况下才会被调用。 1@implementation ViewController23+ (void)load &#123;4 static dispatch_once_t onceToken;5 dispatch_once(&amp;onceToken, ^&#123;6 Class class &#x3D; [self class];7 SEL originalSelector &#x3D; @selector(viewDidLoad);8 SEL swizzledSelector &#x3D; @selector(jkviewDidLoad);9 10 Method originalMethod &#x3D; class_getInstanceMethod(class,originalSelector);11 Method swizzledMethod &#x3D; class_getInstanceMethod(class,swizzledSelector);12 13 &#x2F;&#x2F;judge the method named swizzledMethod is already existed.14 BOOL didAddMethod &#x3D; class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));15 &#x2F;&#x2F; if swizzledMethod is already existed.16 if (didAddMethod) &#123;17 class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));18 &#125;19 else &#123;20 method_exchangeImplementations(originalMethod, swizzledMethod);21 &#125;22 &#125;);23&#125;2425- (void)jkviewDidLoad &#123;26 NSLog(@&quot;替换的方法&quot;);27 28 [self jkviewDidLoad];29&#125;3031- (void)viewDidLoad &#123;32 NSLog(@&quot;自带的方法&quot;);33 34 [super viewDidLoad];35&#125;3637@end 8.KVO的实现 全称是Key-value observing，翻译成键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。 9.实现字典和模型的自动转换(MJExtension) 原理描述：用runtime提供的函数遍历Model自身所有属性，如果属性在json中有对应的值，则将其赋值。核心方法：在NSObject的分类中添加方法。 10.实现NSCoding的自动归档和自动解档 原理描述：用runtime提供的函数遍历Model自身所有属性，并对属性进行encode和decode操作。核心方法：在Model的基类中重写方法。 四.RunLoop1.RunLoop RunLoop是多线程的法宝，即一个线程一次只能执行一个任务，执行完任务后就会退出线程。主线程执行完即时任务时会继续等待接收事件而不退出。非主线程通常来说就是为了执行某一任务的，执行完毕就需要归还资源，因此默认是不运行RunLoop的； 2.每一个线程都有其对应的RunLoop，只是默认只有主线程的RunLoop是启动的，其它子线程的RunLoop默认是不启动的，若要启动则需要手动启动 3.在一个单独的线程中，如果需要在处理完某个任务后不退出，继续等待接收事件，则需要启用RunLoop 4.NSRunLoop提供了一个添加NSTimer的方法，可以指定Mode，如果要让任何情况下都回调，则需要设置Mode为Common模式 5.保证线程的长时间存活 6.保证NSTimer在视图滑动时，依然能正常运转 五.常用的设计模式1.单例模式（Singleton）: 此模式保证对于一个特有的类，只有一个公共的实例存在。它一般与懒加载一起出现，只有被需要时才会创建。单例模式的例子有UserDefaults、UIApplication、UIScreen； 2.观察者模式（Observer）: 它定义对象之间的一种一对多的依赖关系，每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。在iOS中的典型实现是NotificationCenter和KVO；KVO,Key-Value Observer,即键值观察。它是一种没有通知中心的观察者模式的实现方式。一个主体对象管理所有依赖于它的观察者对象，并且在自身状态发生改变时主动通知观察者对象。它的具体实现步骤如下。（1）注册观察者（2）更改主题对象属性的值，即触发发送更改的通知。（3）在制定的回调函数中，处理收到的更改通知。 六.项目的优化快：使用时避免出现卡顿，响应速度快，减少用户等待的时间，满足用户期望。稳：不要在用户使用过程中崩溃和无响应。省：节省流量和耗电，减少用户使用成本，避免使用时导致手机发烫。小：安装包小可以降低用户的安装成本。 1.重用问题： 如UITableViewCells、UICollectionViewCells、UITableViewHeaderFooterViews设置正确的reuseIdentifier，充分重用；尽量把views设置为不透明：当opque为NO的时候，图层的半透明取决于图片和其本身合成的图层为结果，可提高性能； 2.不要使用太复杂的XIB/Storyboard： 载入时就会将XIB/storyboard需要的所有资源，包括图片全部载入内存，即使未来很久才会使用。那些相比纯代码写的延迟加载，性能及内存就差了很多； 3.选择正确的数据结构： 学会选择对业务场景最合适的数组结构是写出高效代码的基础。比如，数组: 有序的一组值。使用索引来查询很快，使用值查询很慢，插入/删除很慢。字典: 存储键值对，用键来查找比较快。集合: 无序的一组值，用值来查找很快，插入/删除很快。 4.延迟加载： 对于不应该使用的数据，使用延迟加载方式。对于不需要马上显示的视图，使用延迟加载方式。比如，网络请求失败时显示的提示界面，可能一直都不会使用到，因此应该使用延迟加载。 5.数据缓存： 对于cell的行高要缓存起来，使得reload数据时，效率也极高。而对于那些网络数据，不需要每次都请求的，应该缓存起来，可以写入数据库，也可以通过plist文件存储，例如个人信息的一些数据，也许会有好几个页面会用到，那么就把数据存入本地，使用的时候根据需要可以直接从本地进行加载。 6.不要阻塞主线程，主线程主要做以下几个方面工作： UI 生命周期控制、系统事件处理、消息处理、界面布局、界面绘制、界面刷新，除此之外，应该尽量避免将其他处理放在主线程中，特别复杂的数据计算和网络请求等。 7.处理内存警告 在app delegate中使用applicationDidReceiveMemoryWarning的方法;注册并接收 UIApplicationDidReceiveMemoryWarningNotification的通知; 8.选择正确的数据存储选项 9.重用和延迟加载(lazy load) Views 更多的view意味着更多的渲染，也就是更多的CPU和内存消耗。不要一次创建所有的subview，而是当需要时才创建。 10.尽量把views设置为透明 如果你有透明的Views你应该设置它们的opaque属性为YES。原因是这会使系统用一个最优的方式渲染这些views。在相对比较静止的画面中，设置这个属性不会有太大影响。然而当这个view嵌在scroll view里边，或者是一个复杂动画的一部分，不设置这个属性的话会在很大程度上影响app的性能。 七、KVC、KVO1.键值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取方法，直接或通过实例变量访问的机制，非对象类型的变量将被自动封装或者解封成对象，很多情况下会简化程序代码 2.KVC的缺点： 一旦使用 KVC 你的编译器无法检查出错误,即不会对设置的键、键路径进行错误检查,且执行效率要低于合成存取器方法和自定的 setter 和 getter 方法。因为使用 KVC 键值编码,它必须先解析字符串,然后在设置或者访问对象的实例变量。 3.键值观察机制是一种能使得对象获取到其他对象属性变化的通知 ，极大的简化了代码 4.实现 KVO 键值观察模式,被观察的对象必须使用 KVC 键值编码来修 改它的实例变量,这样才能被观察者观察到 因此，KVC是KVO的基础。 5.注册观察者(注意：观察者和被观察者不会被保留也不会被释放) 1- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath 2options:(NSKeyValueObservingOptions)options 3context:(void *)context; 6.接收变更通知 1- (void)observeValueForKeyPath:(NSString *)keyPath2ofObject:(id)object change:(NSDictionary *)change context:(void *)context; 7.移除对象的观察者身份 1- (void)removeObserver:(NSObject *)observer2forKeyPath:(NSString *)keyPath; 8.KVO中谁要监听谁注册，然后对响应进行处理，使得观察者与被观察者完全解耦。KVO只检测类中的属性，并且属性名都是通过NSString来查找，编译器不会检错和补全，全部取决于自己 八、Block、通知、代理1.代理 是一种回调机制，且是一对一的关系，Delegate需要定义协议方法，代理对象实现协议方法，并且需要建立代理关系才可以实现通信； 2.通知 是一对多的关系，一个对向所有的观察者提供变更通知； 3.效率： Delegate比NSNOtification高； 4.Block 一般是一对一的通信； Block更加简洁，不需要定义繁琐的协议方法，但通信事件比较多的话，建议使用Delegate； 九、AFNetWorking底层原理1.AFHTTPRequestOperationManager： 内部封装的是 NSURLConnection, 负责发送网络请求, 使用最多的一个类。(3.0废弃) 2.AFHTTPSessionManager： 内部封装是 NSURLSession, 负责发送网络请求,使用最多的一个类。 2.AFNetworkReachabilityManager： 实时监测网络状态的工具类。当前的网络环境发生改变之后,这个工具类就可以检测到。 3. AFSecurityPolicy： 网络安全的工具类, 主要是针对 HTTPS 服务 4.AFURLRequestSerialization： 序列化工具类,基类。上传的数据转换成JSON格式(AFJSONRequestSerializer).使用不多。 6). AFURLResponseSerialization： 反序列化工具类;基类.使用比较多。 7.AFJSONResponseSerializer: JSON解析器,默认的解析器。 8.AFHTTPResponseSerializer: 万能解析器; JSON和XML之外的数据类型,直接返回二进制数据.对服务器返回的数据不做任何处理。 9.AFXMLParserResponseSerializer: XML解析器; 10.Scoket连接和HTTP连接的区别1.HTTP连接： 短连接，客户端向服务器发送一次请求，服务器响应后连接断开，节省资源。服务器不能主动给客户端响应（除非采用HTTP长连接技术），iPhone主要使用类NSURLConnection 2.Socket连接： 长连接，客户端跟服务器端直接使用Socket进行连接，没有规定连接后断开，因此客户端和服务器段保持连接通道，双方可以主动发送数据，一般多用于游戏Socket默认连接超时时间是30秒，默认大小是8K（理解为一个数据包大小） 十一、isa指针1.在 ios 开发中，类也是一个对象，我们称之为类对象， 所有对象中，包含实例对象和类对象，都含有一个isa 指针 实例对象的isa指针， 指向他的类对象，类对象的isa 指针， 指向他的元类。 2.系统判断一个对象属于哪个类，也是通过这个对象的isa指针的指向来判断 3.对象中的成员变量，存储在对象本身，对象的实例方法，存储在他的isa 指针所指向的对象中 即：减号方法存储在类对象中，类方法存储在类对象isa所指向的元类中，成员变量的值储存在对象中。 4.对象在调用减号方法的时候，系统会在对象的isa指针所指向的类对象中寻找方法，这一段在kvo的实现原理中就能看到，kvo的实现原理就是系统动态的生成一个类对象，这个类是监听对象的类的子类，在生成的类中重写了监听属性的set方法，实现对set方法的监听，之后将监听对象的isa指针指向系统动态生成的这个类，当监听对象调用set方法时，由于监听对象的isa指针指向的是刚刚动态生成的类，所以在其中找的的set方法也是重写过有监听功能的set方法，这就是kvo的实现原理。同理，我们也可以通过rutime中的方法设置某个对象isa指针指向的类对象，让对象调用一些原本不属于他的方法 十二、H5、CSS、JavaScript十三、WebView，JS和原生的交互iOS8.0之后，苹果推荐使用WebKit框架中的WKWebView来加载网页，使用WKWebViewConfiguration来配置JS交互。网页切换 1[_webView goBack]; &#x2F;&#x2F;页面后退23[_webView goForward]; &#x2F;&#x2F;页面前进45[_webView reload]; &#x2F;&#x2F;刷新当前页面 JavaSript调用OC 主要依靠WKScriptMessageHandler协议类、WKUserContentController其中:WKUserContentController对象负责注册JS方法，设置处理接收JS方法的代理，代理遵守WKScriptMessageHandler，实现捕捉到JS消息的回调方法。 1、配置与JavaScript的交互 用WKWebViewConfiguration来配置JS交互 2、使用WKUserContentController，用来做 原生与JavaScript的交互管理 3、使用协议类WKScriptMessageHandler，用来处理监听JavaScript方法从而调用原生OC方法。（和WKUserContentController搭配使用） 4、通过 接收JS传出消息的name 进行捕捉的回调方法 ps：遵守WKScriptMessageHandler协议，代理是由WKUserContentControl设置 OC调用JavaSript 使用WKUserScript，执行自定义的JavaScript代码 WKWebView涉及的代理方法 WKNavigationDelegate协议 主要处理一些跳转、加载处理操作 十四、iOS事件响应机制iOS的事件响应必须是UIResponder对象及其子类，我们Command查看层级关系不难发现，UITextView，UILabel，UIButton等控件他们都是UIResponder的子类。这也是他们能够响应事件的基础。 当触摸事件发生时，首先系统通过hitTest方法找到能最合适的view，所谓最合适的view 其实就是 触摸事件 他的触摸点是否在这个View上，一个点可能在多个叠加的视图上，所以系统会找到所有的view（点所在的view），方向是从底下往上，所以判断点的顺序就是父view-&gt;子view-&gt;子view的子view，这样遍历下去，配合pointconvert方法和pointinside方法去判断这个点是否在这个view上，在就遍历他的子view，直到不满足条件。 事件的传递 系统把事件加入到一个由UIApplication管理的事件队列中之所以加入队列而不是栈是因为队列先进先出，意味着先产生的事件，先处理 然后，事件会按照UIApplication -&gt; UIWindow -&gt; SuperView -&gt; SubView的顺序不断的检测 而检测就是靠两个方法hitTest与pointInside 十五、iOS内存管理1.首先，严格的内存管理，能够是我们的应用程在性能上有很大的提高，如果忽略内存管理，可能导致应用占用内存过高，导致程序崩溃 2.内存管理方式主要分为3种: ARC（自动内存计数）、MRC（手动内存计数）、内存池 3.自动内存计数和手动内存计数都是用计数管理 每个对象都有一个引用计数器，每个新对象的计数器是1，当对象的计数器减为0时，就会被销毁；通过retain可以让对象的计数器+1、release可以让对象的计数器-1；保证任何时候指向对象的指针个数和对象的引用计数相同，多一个指针指向这个对象这个对象的引用计数就加1，少一个指针指向这个对象这个对象的引用计数就减1。没有指针指向这个对象对象就被释放了。 4.内存管理遵循谁使用、谁创建；谁引用、谁管理的原则 5.被存入到自动释放池内的对象，当自动释放池被销毁时，会对池内的对象全部做一次release操作 6.自动释放池，什么时候创建? 程序刚启动的时候，也会创建一个自动释放池 产生事件以后，运行循环开始处理事件，就会创建自动释放池 7.什么时候销毁的? 程序运行结束之前销毁 事件处理结束以后，会销毁自动释放池 还有在池子满的时候，也会销毁","categories":[{"name":"总结","slug":"总结","permalink":"https://bondiblue.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bondiblue.github.io/tags/iOS/"}]},{"title":"iOS底层原理总结 - 探寻OC对象的本质","slug":"iOS底层原理总结 - 探寻OC对象的本质","date":"2018-07-17T01:08:40.000Z","updated":"2018-07-18T06:11:20.000Z","comments":true,"path":"2018/07/17/iOS底层原理总结 - 探寻OC对象的本质/","link":"","permalink":"https://bondiblue.github.io/2018/07/17/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93%20-%20%E6%8E%A2%E5%AF%BBOC%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/","excerpt":"","text":"转载自：iOS底层原理总结 对小码哥底层班视频学习的总结与记录。面试题部分，通过对面试题的分析探索问题的本质内容。 面试题：一个NSObject对象占用多少内存？ 探寻OC对象的本质，我们平时编写的Objective-C代码，底层实现其实都是C\\C++代码。 OC的对象结构都是通过基础C\\C++的结构体实现的。我们通过创建OC文件及对象，并将OC文件转化为C++文件来探寻OC对象的本质 OC如下代码 1#import &lt;Foundation/Foundation.h&gt;23int main(int argc, const char * argv[]) &#123;4 @autoreleasepool &#123;5 NSObject *objc = [[NSObject alloc] init];6 NSLog(@\"Hello, World!\");7 &#125;8 return 0;9&#125; 我们通过命令行将OC的mian.m文件转化为c++文件。 1clang -rewrite-objc main.m -o main.cpp // 这种方式没有指定架构例如arm64架构 其中cpp代表（c plus plus）2生成 main.cpp 我们可以指定架构模式的命令行，使用xcode工具 xcrun 1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp 2生成 main-arm64.cpp main-arm64.cpp 文件中搜索NSObjcet，可以找到NSObjcet_IMPL（IMPL代表 implementation 实现） 我们看一下NSObject_IMPL内部 1struct NSObject_IMPL &#123;2 Class isa;3&#125;;4// 查看Class本质5typedef struct objc_class *Class;6//我们发现Class其实就是一个指针，对象底层实现其实就是这个样子。 思考： 一个OC对象在内存中是如何布局的。 NSObjcet的底层实现，点击NSObjcet进入发现NSObject的内部实现 1@interface NSObject &lt;NSObject&gt; &#123;2#pragma clang diagnostic push3#pragma clang diagnostic ignored \"-Wobjc-interface-ivars\"4 Class isa OBJC_ISA_AVAILABILITY;5#pragma clang diagnostic pop6&#125;7@end 转化为c语言其实就是一个结构体 1struct NSObject_IMPL &#123;2 Class isa;3&#125;; 那么这个结构体占多大的内存空间呢，我们发现这个结构体只有一个成员，isa指针，而指针在64位架构中占8个字节。也就是说一个NSObjec对象所占用的内存是8个字节。到这里我们已经可以基本解答第一个问题。但是我们发现NSObject对象中还有很多方法，那这些方法不占用内存空间吗？其实类的方法等也占用内存空间，但是这些方法所占用的存储空间并不在NSObject对象中。 为了探寻OC对象在内存中如何体现，我们来看下面一段代码 1NSObject *objc = [[NSObject alloc] init]; 上面一段代码在内存中如何体现的呢？ 上述一段代码中系统为NSObject对象分配8个字节的内存空间，用来存放一个成员isa指针。 那么isa指针这个变量的地址就是结构体的地址，也就是NSObjcet对象的地址。 假设isa的地址为0x100400110，那么上述代码分配存储空间给NSObject对象，然后将存储空间的地址赋值给objc指针。 objc存储的就是isa的地址 objc指向内存中NSObject对象地址，即指向内存中的结构体，也就是isa的位置。 自定义类的内部实现1@interface Student : NSObject&#123;2 3 @public4 int _no;5 int _age;6&#125;7@end8@implementation Student910int main(int argc, const char * argv[]) &#123;11 @autoreleasepool &#123;1213 Student *stu = [[Student alloc] init];14 stu -&gt; _no = 4;15 stu -&gt; _age = 5;16 17 NSLog(@\"%@\",stu);18 &#125;19 return 0;20&#125;21@end 按照上述步骤同样生成c++文件。并查找Student，我们发现Student_IMPL 1struct Student_IMPL &#123;2 struct NSObject_IMPL NSObject_IVARS;3 int _no;4 int _age;5&#125;; 发现第一个是 NSObject_IMPL的实现。而通过上面的实验我们知道NSObject_IMPL内部其实就是Class isa 那么我们假设 struct NSObject_IMPL NSObject_IVARS; 等价于 Class isa; 可以将上述代码转化为 1struct Student_IMPL &#123;2 Class *isa;3 int _no;4 int _age;5&#125;; 因此此结构体占用多少存储空间，对象就占用多少存储空间。因此结构体占用的存储空间为，isa指针8个字节空间+int类型_no4个字节空间+int类型_age4个字节空间共16个字节空间 1Student *stu = [[Student alloc] init];2stu -&gt; _no = 4;3stu -&gt; _age = 5; 那么上述代码实际上在内存中的体现为，创建Student对象首先会分配16个字节，存储3个东西，isa指针8个字节，4个字节的_no ,4个字节的_age image.png sutdent对象的3个变量分别有自己的地址。而stu指向isa指针的地址。因此stu的地址为0x100400110，stu对象在内存中占用16个字节的空间。并且经过赋值，_no里面存储4 ，_age里面存储5 验证Student在内存中模样 1struct Student_IMPL &#123;2 Class isa;3 int _no;4 int _age;5&#125;;67@interface Student : NSObject8&#123;9 @public10 int _no;11 int _age;12&#125;13@end1415@implementation Student1617int main(int argc, const char * argv[]) &#123;18 @autoreleasepool &#123;19 // 强制转化20 struct Student_IMPL *stuImpl = (__bridge struct Student_IMPL *)stu;21 NSLog(@\"_no = %d, _age = %d\", stuImpl-&gt;_no, stuImpl-&gt;_age); // 打印出 _no = 4, _age = 522 &#125;23 return 0;24&#125; 上述代码将oc对象强转成Student_IMPL的结构体。也就是说把一个指向oc对象的指针，指向这种结构体。由于我们之前猜想，对象在内存中的布局与结构体在内存中的布局相同，那么如果可以转化成功，说明我们的猜想正确。由此说明stu这个对象指向的内存确实是一个结构体。 实际上想要获取对象占用内存的大小，可以通过更便捷的运行时方法来获取。 1class_getInstanceSize([Student class])2NSLog(@\"%zd,%zd\", class_getInstanceSize([NSObject class]) ,class_getInstanceSize([Student class]));3// 打印信息 8和16 窥探内存结构实时查看内存数据 方式一：通过打断点。 Debug Workflow -&gt; viewMemory address中输入stu的地址 image 从上图中，我们可以发现读取数据从高位数据开始读，查看前16位字节，每四个字节读出的数据为 16进制 0x0000004(4字节) 0x0000005(4字节) isa的地址为 00D1081000001119(8字节) 方式二：通过lldb指令xcode自带的调试器 1memory read 0x10074c4502// 简写 x 0x10074c45034// 增加读取条件5// memory read/数量格式字节数 内存地址6// 简写 x/数量格式字节数 内存地址7// 格式 x是16进制，f是浮点，d是10进制8// 字节大小 b：byte 1字节，h：half word 2字节，w：word 4字节，g：giant word 8字节910示例：x/4xw // /后面表示如何读取数据 w表示4个字节4个字节读取，x表示以16进制的方式读取数据，4则表示读取4次 同时也可以通过lldb修改内存中的值 1memory write 0x100400c68 62将_no的值改为了6 image 那么一个NSObject对象占用多少内存？ NSObjcet实际上是只有一个名为isa的指针的结构体，因此占用一个指针变量所占用的内存空间大小，如果64bit占用8个字节，如果32bit占用4个字节。 更复杂的继承关系 面试题：在64bit环境下， 下面代码的输出内容？ 1/* Person */2@interface Person : NSObject3&#123;4 int _age;5&#125;6@end78@implementation Person9@end1011/* Student */12@interface Student : Person13&#123;14 int _no;15&#125;16@end1718@implementation Student19@end2021int main(int argc, const char * argv[]) &#123;22 @autoreleasepool &#123;2324 NSLog(@\"%zd %zd\",25 class_getInstanceSize([Person class]),26 class_getInstanceSize([Student class])27 );28 &#125;29 return 0;30&#125; 这道面试题的实质是想问一个Person对象，一个Student对象分别占用多少内存空间？ 我们依据上面的分析与发现，类对象实质上是以结构体的形式存储在内存中，画出真正的内存图例 image 我们发现只要是继承自NSObject的对象，那么底层结构体内一定有一个isa指针。 那么他们所占的内存空间是多少呢？单纯的将指针和成员变量所占的内存相加即可吗？上述代码实际打印的内容是16 16，也就是说，person对象和student对象所占用的内存空间都为16个字节。 其实实际上person对象确实只使用了12个字节。但是因为内存对齐的原因。使person对象也占用16个字节。 编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能是该基本数据类型的整倍的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为对齐模数。 为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。 我们可以总结内存对齐为两个原则： 原则 1. 前面的地址必须是后面的地址正数倍,不是就补齐。 原则 2. 整个Struct的地址必须是最大字节的整数倍。 通过上述内存对齐的原则我们来看，person对象的第一个地址要存放isa指针需要8个字节，第二个地址要存放_age成员变量需要4个字节，根据原则一，8是4的整数倍，符合原则一，不需要补齐。然后检查原则2，目前person对象共占据12个字节的内存，不是最大字节数8个字节的整数倍，所以需要补齐4个字节，因此person对象就占用16个字节空间。 而对于student对象，我们知道sutdent对象中，包含person对象的结构体实现，和一个int类型的_no成员变量，同样isa指针8个字节，_age成员变量4个字节，_no成员变量4个字节，刚好满足原则1和原则2，所以student对象占据的内存空间也是16个字节。 OC对象的分类 面试题：OC的类信息存放在哪里。 面试题：对象的isa指针指向哪里。 示例代码 1#import &lt;Foundation/Foundation.h&gt;2#import &lt;objc/runtime.h&gt;34/* Person */ 5@interface Person : NSObject &lt;NSCopying&gt;6&#123;7 @public8 int _age;9&#125;10@property (nonatomic, assign) int height;11- (void)personMethod;12+ (void)personClassMethod;13@end1415@implementation Person16- (void)personMethod &#123;&#125;17+ (void)personClassMethod &#123;&#125;18@end1920/* Student */21@interface Student : Person &lt;NSCoding&gt;22&#123;23 @public24 int _no;25&#125;26@property (nonatomic, assign) int score;27- (void)studentMethod;28+ (void)studentClassMethod;29@end3031@implementation Student32- (void)studentMethod &#123;&#125;33+ (void)studentClassMethod &#123;&#125;34@end3536int main(int argc, const char * argv[]) &#123;37 @autoreleasepool &#123; 38 NSObject *object1 = [[NSObject alloc] init];39 NSObject *object2 = [[NSObject alloc] init];4041 Student *stu = [[Student alloc] init];42 [Student load];4344 Person *p1 = [[Person alloc] init];45 p1-&gt;_age = 10;46 [p1 personMethod];47 [Person personClassMethod];48 Person *p2 = [[Person alloc] init];49 p2-&gt;_age = 20;50 &#125;51 return 0;52&#125; OC的类信息存放在哪里 OC对象主要可以分为三种 instance对象（实例对象） class对象（类对象） meta-class对象（元类对象） instance对象就是通过类alloc出来的对象，每次调用alloc都会产生新的instance对象 1NSObjcet *object1 = [[NSObjcet alloc] init];2NSObjcet *object2 = [[NSObjcet alloc] init]; object1和object2都是NSObject的instace对象（实例对象），但他们是不同的两个对象，并且分别占据着两块不同的内存。 instance对象在内存中存储的信息包括 isa指针 其他成员变量 image 衍生问题：在上图实例对象中根本没有看到方法，那么实例对象的方法的代码放在什么地方呢？那么类的方法的信息，协议的信息，属性的信息都存放在什么地方呢？ class对象 我们通过class方法或runtime方法得到一个class对象。class对象也就是类对象 1Class objectClass1 = [object1 class];2Class objectClass2 = [object2 class];3Class objectClass3 = [NSObject class];45// runtime6Class objectClass4 = object_getClass(object1);7Class objectClass5 = object_getClass(object2);8NSLog(@\"%p %p %p %p %p\", objectClass1, objectClass2, objectClass3, objectClass4, objectClass5); 每一个类在内存中有且只有一个class对象。可以通过打印内存地址证明 class对象在内存中存储的信息主要包括 isa指针 superclass指针 类的属性信息（@property），类的成员变量信息（ivar） 类的对象方法信息（instance method），类的协议信息（protocol） image 成员变量的值时存储在实例对象中的，因为只有当我们创建实例对象的时候才为成员变赋值。但是成员变量叫什么名字，是什么类型，只需要有一份就可以了。所以存储在class对象中。 类方法放在那里？ 元类对象 meta-class 1//runtime中传入类对象此时得到的就是元类对象2Class objectMetaClass = object_getClass([NSObject class]);3// 而调用类对象的class方法时得到还是类对象，无论调用多少次都是类对象4Class cls = [[NSObject class] class];5Class objectClass3 = [NSObject class];6class_isMetaClass(objectMetaClass) // 判断该对象是否为元类对象7NSLog(@\"%p %p %p\", objectMetaClass, objectClass3, cls); // 后面两个地址相同，说明多次调用class得到的还是类对象 每个类在内存中有且只有一个meta-class对象。 meta-class对象和class对象的内存结构是一样的，但是用途不一样，在内存中存储的信息主要包括 isa指针 superclass指针 类的类方法的信息（class method） image meta-class对象和class对象的内存结构是一样的，所以meta-class中也有类的属性信息，类的对象方法信息等成员变量，但是其中的值可能是空的。 对象的isa指针指向哪里 当对象调用实例方法的时候，我们上面讲到，实例方法信息是存储在class类对象中的，那么要想找到实例方法，就必须找到class类对象，那么此时isa的作用就来了。 1[stu studentMethod]; instance的isa指向class，当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现进行调用。 当类对象调用类方法的时候，同上，类方法是存储在meta-class元类对象中的。那么要找到类方法，就需要找到meta-class元类对象，而class类对象的isa指针就指向元类对象 1[Student studentClassMethod]; class的isa指向meta-class 当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用 image 当对象调用其父类对象方法的时候，又是怎么找到父类对象方法的呢？，此时就需要使用到class类对象superclass指针。 1[stu personMethod];2[stu init]; 当Student的instance对象要调用Person的对象方法时，会先通过isa找到Student的class，然后通过superclass找到Person的class，最后找到对象方法的实现进行调用，同样如果Person发现自己没有响应的对象方法，又会通过Person的superclass指针找到NSObject的class对象，去寻找响应的方法 image 当类对象调用父类的类方法时，就需要先通过isa指针找到meta-class，然后通过superclass去寻找响应的方法 1[Student personClassMethod];2[Student load]; 当Student的class要调用Person的类方法时，会先通过isa找到Student的meta-class，然后通过superclass找到Person的meta-class，最后找到类方法的实现进行调用 最后又是这张静定的isa指向图，经过上面的分析我们在来看这张图，就显得清晰明了很多。 image 对isa、superclass总结 instance的isa指向class class的isa指向meta-class meta-class的isa指向基类的meta-class，基类的isa指向自己 class的superclass指向父类的class，如果没有父类，superclass指针为nil meta-class的superclass指向父类的meta-class，基类的meta-class的superclass指向基类的class instance调用对象方法的轨迹，isa找到class，方法不存在，就通过superclass找父类 class调用类方法的轨迹，isa找meta-class，方法不存在，就通过superclass找父类 如何证明isa指针的指向真的如上面所说？我们通过如下代码证明： 1NSObject *object = [[NSObject alloc] init];2Class objectClass = [NSObject class];3Class objectMetaClass = object_getClass([NSObject class]);45NSLog(@\"%p %p %p\", object, objectClass, objectMetaClass); 打断点并通过控制台打印相应对象的isa指针 image 我们发现object-&gt;isa与objectClass的地址不同，这是因为从64bit开始，isa需要进行一次位运算，才能计算出真实地址。而位运算的值我们可以通过下载objc源代码找到。 image 我们通过位运算进行验证。 image 我们发现，object-isa指针地址0x001dffff96537141经过同0x00007ffffffffff8位运算，得出objectClass的地址0x00007fff96537140 接着我们来验证class对象的isa指针是否同样需要位运算计算出meta-class对象的地址。 当我们以同样的方式打印objectClass-&gt;isa指针时，发现无法打印 image 同时也发现左边objectClass对象中并没有isa指针。我们来到Class内部看一下 1typedef struct objc_class *Class;23struct objc_class &#123;4 Class _Nonnull isa OBJC_ISA_AVAILABILITY;56#if !__OBJC2__7 Class _Nullable super_class OBJC2_UNAVAILABLE;8 const char * _Nonnull name OBJC2_UNAVAILABLE;9 long version OBJC2_UNAVAILABLE;10 long info OBJC2_UNAVAILABLE;11 long instance_size OBJC2_UNAVAILABLE;12 struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE;13 struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE;14 struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE;15 struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;16#endif1718&#125; OBJC2_UNAVAILABLE;19/* Use `Class` instead of `struct objc_class *` */ 相信了解过isa指针的同学对objc_class结构体内的内容很熟悉了，今天这里不深入研究，我们只看第一个对象是一个isa指针，为了拿到isa指针的地址，我们自己创建一个同样的结构体并通过强制转化拿到isa指针。 1struct xx_cc_objc_class&#123;2 Class isa;3&#125;;45Class objectClass = [NSObject class];6struct xx_cc_objc_class *objectClass2 = (__bridge struct xx_cc_objc_class *)(objectClass); 此时我们重新验证一下 image 确实，objectClass2的isa指针经过位运算之后的地址是meta-class的地址。 本文面试题总结： 一个NSObject对象占用多少内存？ 答：一个指针变量所占用的大小（64bit占8个字节，32bit占4个字节） 对象的isa指针指向哪里？ 答：instance对象的isa指针指向class对象，class对象的isa指针指向meta-class对象，meta-class对象的isa指针指向基类的meta-class对象，基类自己的isa指针也指向自己。 OC的类信息存放在哪里？ 答：成员变量的具体值存放在instance对象。对象方法，协议，属性，成员变量信息存放在class对象。类方法信息存放在meta-class对象。 底层原理相关文章：iOS底层原理总结 - 文集","categories":[{"name":"iOS","slug":"iOS","permalink":"https://bondiblue.github.io/categories/iOS/"}],"tags":[{"name":"OC","slug":"OC","permalink":"https://bondiblue.github.io/tags/OC/"}]}]}