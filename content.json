{"meta":{"title":"Bondi_blue","subtitle":"","description":"Colin的个人博客","author":"Colin Jin","url":"https://bondiblue.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-11-28T04:14:20.999Z","updated":"2019-11-28T04:14:20.999Z","comments":true,"path":"404.html","permalink":"https://bondiblue.github.io/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"tags","date":"2019-11-28T03:55:55.764Z","updated":"2019-11-28T03:55:55.758Z","comments":true,"path":"tags/index.html","permalink":"https://bondiblue.github.io/tags/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-12-15T16:23:29.836Z","updated":"2019-12-15T16:22:45.747Z","comments":true,"path":"about/index.html","permalink":"https://bondiblue.github.io/about/index.html","excerpt":"","text":"滴水不漏，滴水穿石！ 自我介绍我是个快乐的小码农，钟情于iOS开发，喜欢电影、小说和各种风格的纯音乐，喜欢乒乓球篮球，讨厌唱跳Rap"},{"title":"我的朋友们","date":"2018-10-23T01:33:09.000Z","updated":"2019-11-28T11:48:41.392Z","comments":true,"path":"friends/index.html","permalink":"https://bondiblue.github.io/friends/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-11-28T03:41:13.627Z","updated":"2019-11-28T03:41:13.627Z","comments":true,"path":"categories/index.html","permalink":"https://bondiblue.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"iOS开发中的pch文件","slug":"iOS开发中的pch文件","date":"2019-12-19T15:11:23.000Z","updated":"2019-12-19T15:11:23.000Z","comments":true,"path":"2019/12/19/iOS开发中的pch文件/","link":"","permalink":"https://bondiblue.github.io/2019/12/19/iOS%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84pch%E6%96%87%E4%BB%B6/","excerpt":"","text":"pch文件是什么预编译头文件(一般扩展名为.pch)，是把一个工程中较稳定的代码预先编译好放在一个文件里。这些预先编译好的代码可以是任何的C/C++代码，甚至可以是inline函数，它们在整个工程中是较为稳定的，即在工程开发过程中不会经常被修改的代码。 pch文件在iOS项目中的作用 存放公有头文件：文件中存放预编译的头文件，使得我们不用再项目中使用的时候再去引入头文件 存放公有宏：可以将全局的宏存放在pch文件中，提供全局使用 自定义log pch文件原理：把pch当中的所有内容拷贝到工程当中的每一个文件 注意：OC文件对pch文件中的OC自定义的内容识别但对C文件不识别会报错，如果有C文件要做判断，每一个OC文件内部都默认有一个隐式宏：”–OBJC–”。 pch文件的优缺点优点很明了了，方便我们在项目中使用一些预先定义好的宏和头文件； 缺点就是如果预编译文件比较大的时候会影响编译速度，对于App来说，启动前处理编译代码比较耗时，导致App启动慢，不过如果不是预编译文件特别大一般还是看不出来对App有什么影响的，可以自己试一试。 iOS项目怎么创建pch文件1、打开项目，Cmd+N，iOS下有一个PCH File的文件类型，选中Next。 2、 命名，一般以项目名+Prefix.pch命名，例如：DemoPrefix.pch。 3、打开文件如下图： 这个文件中放预编译文件，宏，头文件等。 4、配置pch文件路径 Xcode有绝对路径和相对路径，看一个文件的绝对路径将这个文件拖拽至终端，出现的路径就是绝对路径。我们需要在Xcode里设置pch的相对路径，如果你设置的是绝对路径，那么你的项目换了位置，pch文件将会找到。 为什么要设置路径，以我的理解因为Xcode在编译和处理文件的时候需要根据其文件路径去寻找相应的文件，如果不设置路径，Xcode找不到该文件，则编译的时候编译不上或者编译报错。 打开TARGETS，在Build Settings下面搜索Prefix Header，找到Prefix Header，点击右侧空白处，如下图所示： 在框里面输入$(SRCROOT)/项目名/…/一级一级的文件夹名，直到到pch文件的文件名为止，如图： 这样就可以了。 这里有一点需要注意一下就是，导入问价你路径的时候，如果不是真实存在的文件夹，导入路径的时候可以不写文件夹名字，比如项目中的Supporting Files文件，鼠标右击，show in finder的时一看，这个文件夹并不是真实存在的，所以设置$(SRCROOT)/项目名/…/一级一级的文件夹名的时候不能引入该文件夹名，如果引入则会报错，因为路径错误系统找不到pch文件 报错1、如果系统报找不到pch文件的错误，则肯定是路径设置问题，如下图错误信息： 这时候就去老老实实的检查设置的pch文件路径是否正确吧。","categories":[{"name":"总结","slug":"总结","permalink":"https://bondiblue.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"pch","slug":"pch","permalink":"https://bondiblue.github.io/tags/pch/"}]},{"title":"Xcode自动补全失效的问题","slug":"Xcode自动补全失效问题","date":"2019-10-19T02:12:40.000Z","updated":"2019-10-19T02:12:40.000Z","comments":true,"path":"2019/10/19/Xcode自动补全失效问题/","link":"","permalink":"https://bondiblue.github.io/2019/10/19/Xcode%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/","excerpt":"","text":"退出 Xcode 找到 这个 DerivedData 文件夹 删除 (路径: ~/Library/Developer/Xcode/DerivedData) 删除这个 com.apple.dt.Xcode 文件 (路径: ~/Library/Caches/com.apple.dt.Xcode)","categories":[{"name":"总结","slug":"总结","permalink":"https://bondiblue.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"Xcode使用","slug":"Xcode使用","permalink":"https://bondiblue.github.io/tags/Xcode%E4%BD%BF%E7%94%A8/"}]},{"title":"iOS多线程知识梳理","slug":"iOS 多线程知识梳理","date":"2019-10-18T02:12:40.000Z","updated":"2019-10-21T07:13:20.000Z","comments":true,"path":"2019/10/18/iOS 多线程知识梳理/","link":"","permalink":"https://bondiblue.github.io/2019/10/18/iOS%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/","excerpt":"","text":"进程、线程与队列进程与线程 进程是系统中正在运行的一个应用程序，每个进程之间是独立的，每个进程均运行在专用且受保护的内存空间内 线程是进程的基本执行单元，一个进程中的任务都在线程中执行，所以一个进程由至少一个线程组成 多线程一个线程中的任务是串行的，同一时间内，一个线程只能执行一个任务。 一个进程可以开启多条线程，每条线程可以并行执行不同的任务。同一时间，CPU只能处理一条线程，多线程并发执行是CPU快速地在多条线程之间调度 iOS的多线程技术有：pthread、NSThread、GCD、NSOperation 主线程主线程主要负责显示和刷新UI界面，处理UI事件 队列的类型 主队列：dispatch_get_main_queue 全局并发队列：dispatch_get_global_queue 自己创建队列：dispatch_queue_create 线程通信GCD: 1dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;2 &#x2F;&#x2F; 在这里执行耗时操作3 dispatch_async(dispatch_get_main_queue(), ^&#123;4 &#x2F;&#x2F; 回到主线程，执行UI刷新操作5 &#125;);6&#125;); NSOperationQueue: 1[[NSOperationQueue new] addOperationWithBlock:^&#123;2 NSLog(@&quot;子线程下载: %@&quot;, NSOperationQueue.currentQueue);3 [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;4 NSLog(@&quot;主线程刷新UI: %@&quot;, NSOperationQueue.currentQueue);5 &#125;];6&#125;]; 死锁死锁就是队列引起的循环等待：在串行队列A中向队列A添加一个同步任务，例如主队列同步： 1- (void)viewDidLoad &#123;2 [super viewDidLoad];3 dispatch_sync(dispatch_get_main_queue(), ^&#123; &#x2F;&#x2F; 👈死锁在这一行4 &#x2F;&#x2F; NSLog(@&quot;在主队列同步执行&quot;);5 &#125;);6&#125; 或者在自定义线程中： 1&#x2F;&#x2F; NOT OK2- (void)test1 &#123;3 NSLog(@&quot;在主线程添加一个串行队列queue&quot;);4 dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);5 dispatch_async(queue, ^&#123;6 NSLog(@&quot;在串行队列queue中添加一个同步任务&quot;);7 dispatch_sync(queue, ^&#123; &#x2F;&#x2F; 👈死锁在这一行8 NSLog(@&quot;OK&quot;);9 &#125;);10 &#125;);11&#125;1213&#x2F;&#x2F; 这样就不会死锁了14- (void)test2 &#123;15 NSLog(@&quot;在主线程添加一个串行队列queue&quot;);16 dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);17 dispatch_queue_t queue2 &#x3D; dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_SERIAL);18 dispatch_async(queue, ^&#123;19 NSLog(@&quot;在串行队列queue2中添加一个同步任务&quot;);20 dispatch_sync(queue2, ^&#123;21 NSLog(@&quot;OK&quot;);22 &#125;);23 &#125;);24&#125; 线程管理设置最大并发数NSOperationQueue： 1- (void)setMaxConcurrentOperationCount:(NSInteger)cnt; 设置依赖1NSOperationQueue *queue &#x3D; [[NSOperationQueue alloc] init];2NSOperation *op1 &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;3 sleep(1);4 NSLog(@&quot;下载图片1&quot;);5&#125;];6NSOperation *op2 &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;7 sleep(1);8 NSLog(@&quot;下载图片2&quot;);9&#125;];10NSOperation *combine &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;11 NSLog(@&quot;合成图片&quot;);12&#125;];13[combine addDependency:op1];14[combine addDependency:op2];1516[queue addOperation:op1];17[queue addOperation:op2];18[queue addOperation:combine]; 设置栅栏若干个网络请求结束后执行下一步操作： 1dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;test&quot;, DISPATCH_QUEUE_CONCURRENT);2dispatch_group_t group &#x3D; dispatch_group_create();3for (int i &#x3D; 0; i &lt; 10; i++) &#123;4 dispatch_group_async(group, queue, ^&#123;5 sleep(1);6 NSLog(@&quot;网络请求 ---- %d&quot;,i);7 &#125;);8&#125;9dispatch_barrier_sync(queue, ^&#123;10 NSLog(@&quot;主线程刷新UI&quot;);11&#125;); 通过NSOperationQueue实现： 1NSOperationQueue *queue &#x3D; [[NSOperationQueue alloc] init];2for (int i &#x3D; 0; i &lt; 10; i++) &#123;3 NSOperation *op &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;4 sleep(1);5 NSLog(@&quot;网络请求 ---- %d&quot;,i);6 &#125;];7 [queue addOperation:op];8&#125;9[queue addBarrierBlock:^&#123;10 NSLog(@&quot;刷新页面&quot;);11&#125;]; 线程组在n个耗时并发任务都完成后，再去执行接下来的任务。比如，在n个网络请求完成后去刷新UI页面 1dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);2dispatch_group_t group &#x3D; dispatch_group_create();3for (int i &#x3D; 0; i &lt; 10; i++) &#123;4 dispatch_group_async(group, queue, ^&#123;5 NSLog(@&quot;网络请求 ---- %d&quot;,i);6 &#125;);7&#125;8dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;9 NSLog(@&quot;刷新页面&quot;);10&#125;); GCD和NSOperation有什么区别 GCD是纯C语言的API；NSOperation是基于GCD的OC版本封装 GCD只支持FIFO的队列；NSOperation可以很方便地调整执行顺序，设置最大并发数量 NSOperationQueue可以轻松在operation间设置依赖关系，而GCD需要些很多代码才能实现 NSOperationQueue支持KVO，可以检测operation是否正在执行(isExecuted)，是否结束(isFinish),是否取消(isCancel) GCD的执行速度比NSOperation快","categories":[],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://bondiblue.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"SwiftUI实践Demo","slug":"SwiftUI学习笔记及实践","date":"2019-10-17T02:12:40.000Z","updated":"2019-10-21T07:13:20.000Z","comments":true,"path":"2019/10/17/SwiftUI学习笔记及实践/","link":"","permalink":"https://bondiblue.github.io/2019/10/17/SwiftUI%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%8F%8A%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"SwiftUI入门学习实践Apple Developer SwiftUI 一、SwiftUI是什么？1. 定义：SwiftUI是苹果在 “WWDC-2019” 推出的一款全新的 “声明式UI” 框架。 拆开看，Swift + UI，即基于Swift语言基础语法的UI框架 2. 特点： “简洁迅速”的Swift：越来越简洁的Swift语法，配上Swift迅速的优势 “即视”的UI：降低调试成本，一边写code、一边就可实时预览查看UI界面 跨平台：一套代码，即可完成iOS、iPadOS、macOS、watchOS的开发与适配 “声明式”编程： 对比之前的 “指令式”编程，我们通常需要告诉计算机“怎么做”？ 而“声明式”编程是让我们告诉计算机 “做什么”？（至于最底层怎么做，开发者无需关心） 举个例子，对于写UI而言， 指令式编程：就是，怎么画？ 把每个frame、layout等等统统需要计算到位 声明式编程：就是，画什么？ 把想要的效果描述出来，其他都交给框架去做 3. 开发环境：这么新的技术肯定需要环境的支持。SwiftUI所需要的开发环境，如下： Xcode：Xcode 11.1+ MacOS：MacOS 10.15+ iOS：iOS 13+ PS：由于SwiftUI只能应用与iOS 13系统以上的设备。 因此，这项技术不建议用在需要适配低版本（iOS 13 以下）的App上。 不过如果是无需适配低版本的新项目，或者学习者全可以上手“玩一玩”。 毕竟苹果的新技术还是很有意思的嘛~ 二、SwiftUI的基本组件（语法） 这块知识比较“基础”且“重要”。只有记住了这些基本组件，才能用较少的代码开发出精美的App 下面是一些重要的SwiftUI组件： 组件介绍 名称 含义 Text 用来显示文本的组件，类似UIKit中的UILabel Image 用来展示图片的组件，类似UIKit中的UIImageView Button 用于可点击的按钮组件，类似UIKit中的UIButton List 用来展示列表的组件，类似UIKit中的UITableView ScrollView 用来支持滑动的组件，类似UIKit中的UIScrollView Spacer 一个灵活的空间，用来填充空白的组件 Divider 一条分割线，用来划分区域的组件 VStack 将子视图按“竖直方向”排列布局。（Vertical stack） HStack 将子视图按“水平方向”排列布局。（Horizontal stack） ZStack 将子视图按“两轴方向均对齐”布局（居中，有重叠效果） 基本组件 Text：用来显示文本的组件，类似UIKit中的UILabel 1Text(\"Hello, we are QiShare!\").foregroundColor(.blue).font(.system(size: 32.0)) Image：用来展示图片的组件，类似UIKit中的UIImageView 1Image.init(systemName: \"star.fill\").foregroundColor(.yellow) Button：用于可点击的按钮组件，类似UIKit中的UIButton 1Button(action: &#123; self.showingProfile.toggle() &#125;) &#123;2 Image(systemName: \"paperplane.fill\")3 .imageScale(.large)4 .accessibility(label: Text(\"Right\"))5 .padding()6&#125; List：用来展示列表的组件，类似UIKit中的UITableView 1List(0..&lt;5)&#123;_ in2 NavigationLink.init(destination: VStack(alignment:.center)&#123;3 Image.init(systemName: \"\\(item+1).square.fill\").foregroundColor(.green)4 Text(\"详情界面\\(item + 1)\").font(.system(size: 16))5 &#125;) &#123;6 //ListRow7 &#125; ScrollView：用来支持滑动的组件，类似UIKit中的UIScrollView Spacer：一个灵活的空间，用来填充空白的组件 Divider：一条分割线，用来划分区域的组件 布局组件 VStack：将子视图按“Y轴竖直方向”布局（Vertical stack） HStack：将子视图按“X轴水平方向”布局（Horizontal stack） ZStack：将子视图按“XY两轴方向均对齐”布局 功能组件 NavigationView：负责App中导航功能的组件，类似UIKit中的UINavigationView NavigationLink：负责App页面跳转的组件，类似于UINavigationView中的push与pop功能 1NavigationView &#123;2 List(0..&lt;5)&#123;_ in3 NavigationLink.init(destination: VStack(alignment:.center)&#123;4 Image.init(systemName: \"\\(item+1).square.fill\").foregroundColor(.green)5 Text(\"详情界面\\(item + 1)\").font(.system(size: 16))6 &#125;) &#123;7 //ListRow8 &#125;9&#125;10.navigationBarTitle(\"导航\\(item)\",displayMode: .inline) TabView：负责App中的标签页功能的组件，类似UIKit中的UITabBarController 1TabView &#123;2 Text(\"The First Tab\")3 .tabItem &#123;4 Image(systemName: \"1.square.fill\")5 Text(\"First\")6 &#125;7 Text(\"Another Tab\")8 .tabItem &#123;9 Image(systemName: \"2.square.fill\")10 Text(\"Second\")11 &#125;12 Text(\"The Last Tab\")13 .tabItem &#123;14 Image(systemName: \"3.square.fill\")15 Text(\"Third\")16 &#125;17&#125;18.font(.headline) 三、SwiftUI快速上手实践下面来快速实现一个有TabView、NavigationView、List的简单示例Demo SF Symbols 是从 iOS 13 和 macOS 10.15 开始内置于系统中的字符图标库，它提供了上千种常见的线条图标，而且我们可以任意地为它们设置尺寸，颜色等属性。Apple 甚至准备了专门的app：SF Symbols 来帮助你查看可用的符号： 接下来就让我们用这些Symbols制作个小Demo ContentView.swift： 1import SwiftUI23struct ContentView: View &#123;4 5 @State var isLeftNav = false6 @State var isRightNav = false7 8 init() &#123;9 //修改导航栏文字颜色10 UINavigationBar.appearance().largeTitleTextAttributes = [.foregroundColor: UIColor.systemBlue]11 UINavigationBar.appearance().titleTextAttributes = [.foregroundColor: UIColor.systemBlue]12 UINavigationBar.appearance().tintColor = .systemBlue13 &#125;14 15 var body: some View &#123;16 TabView &#123;17 18 // Tab1:19 NavigationView &#123;20 List(Symbols, id:\\.self) &#123;21 ListRow(symbol: $0)22 &#125;23 .navigationBarTitle(Text(\"SF Symbols\"))24 .navigationBarItems(leading: leftNavButton, trailing: rightNavButton)25 &#125;.tabItem &#123;26 Image.init(systemName: \"star.fill\")27 Text(\"Tab1\").font(.subheadline)28 &#125;29 30 // Tab2:31 NavigationView &#123;32 Text(\"This is the second tab.\")33 &#125;.tabItem &#123;34 Image.init(systemName: \"star.fill\")35 Text(\"Tab2\").font(.subheadline)36 &#125;37 &#125;38 &#125;39 40 var leftNavButton: some View &#123;41 Button(action: &#123; self.isLeftNav.toggle() &#125;) &#123;42 Image(systemName: \"person.crop.circle\")43 .imageScale(.large)44 .accessibility(label: Text(\"Left\"))45 .padding()46 &#125;47 .sheet(isPresented: $isLeftNav) &#123;48 VStack &#123;49 Text(\"Hello, we are QiShare!\").foregroundColor(.blue).font(.system(size: 32.0))5051 HStack &#123;52 Spacer()53 Spacer()54 Text(\"an iOS Team. \").fontWeight(.black).foregroundColor(.purple)55 Spacer()56 Text(\"We are learning SwiftUI.\").foregroundColor(.blue)57 Spacer()58 &#125;59 &#125;60 &#125;61 &#125;62 63 var rightNavButton: some View &#123;64 Button(action: &#123; self.isRightNav.toggle() &#125;) &#123;65 Image(systemName: \"paperplane.fill\")66 .imageScale(.large)67 .accessibility(label: Text(\"Right\"))68 .padding()69 &#125;70 .sheet(isPresented: $isRightNav, onDismiss: &#123;71 print(\"dissmiss RrightNav\")72 &#125;) &#123;73 ZStack &#123;74 Text(\"This is the Right Navi Button.\")75 &#125;76 &#125;77 &#125;78&#125; ListRow.swift：List对应的Cell 1struct ListRow: View &#123;2 var symbol: String3 var body: some View &#123;4 NavigationLink(destination: ListDetail(symbol: symbol)) &#123;5 6 HStack &#123;7 //图片8 Image(systemName: symbol)9 .resizable()10 .frame(width: 60, height: 60)11 .foregroundColor(Colors.randomElement())12 //分割13 Divider()14 Spacer()15 //文字16 Text(symbol)17 Spacer()18 &#125;19 &#125;20 &#125;21&#125; ListDetail.swift： 1import SwiftUI23struct ListDetail: View &#123;4 5 var symbol: String6 7 var body: some View &#123;8 VStack &#123;9 10 Text(\"Image:\").font(.headline)11 12 Spacer()13 14 Image(systemName: symbol)15 .foregroundColor(Colors.randomElement())16 .imageScale(.large)17 .scaleEffect(3)18 .padding(.bottom, 100)19 20 Divider()21 22 Text(\"Image Name:\").font(.headline)23 Spacer()24 Text(symbol)25 .font(.largeTitle)26 Spacer()27 &#125;28 .navigationBarTitle(symbol)29 &#125;30&#125;","categories":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://bondiblue.github.io/categories/SwiftUI/"}],"tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"https://bondiblue.github.io/tags/SwiftUI/"}]},{"title":"如何封装Framework静态库","slug":"如何封装 Framework 静态库","date":"2019-10-13T02:12:40.000Z","updated":"2019-10-13T07:13:20.000Z","comments":true,"path":"2019/10/13/如何封装 Framework 静态库/","link":"","permalink":"https://bondiblue.github.io/2019/10/13/%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%20Framework%20%E9%9D%99%E6%80%81%E5%BA%93/","excerpt":"","text":"工作中使用的第三方SDK基本上都是闭源的，因为公司不能把自己的机密泄露出去。所以当需要给别人提供SDK但不让他们知道代码的实现时就需要封装成静态库 静态库有.a库和.framework库，苹果官方更建议我们使用.framework库，因为其更加强大 .a是一个纯二进制文件，.framework中除了有二进制文件之外还有资源文件.a文件不能直接使用，至少要有.h文件配合，.framework文件可以直接使用.a + .h + sourceFile = .framework 步骤参考这篇博客： iOS开发——创建你自己的Framework 讲解的非常详细 总结一下步骤： 创建工程，最好是起名为xxxDemo例如AXKitDemo，然后新建一个target名为AXKit，并把原来的工程改名为AXKit（为了方便在demo中调试静态库） 新建一个target，选择类型为framework 在framework中创建需要封装的类，写好代码 在Build Setting里更改参数，Math-O Type为Static Library 在Build Phases -&gt; Headers里将需要暴露出来的头文件从Project移动到Public 添加一个Aggregate的target，并添加运行脚本。目的是把编译出来的真机版和模拟器版的framework合并 模拟器编译一下，真机编译一下，然后Aggregate编译一下，然后在项目的Products文件夹里就有了最终生成的静态库 Aggregate的Run Script脚本： 1if [ \"$&#123;ACTION&#125;\" = \"build\" ]2then3INSTALL_DIR=$&#123;SRCROOT&#125;/Products/$&#123;PROJECT_NAME&#125;.framework45DEVICE_DIR=$&#123;BUILD_ROOT&#125;/$&#123;CONFIGURATION&#125;-iphoneos/$&#123;PROJECT_NAME&#125;.framework67SIMULATOR_DIR=$&#123;BUILD_ROOT&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/$&#123;PROJECT_NAME&#125;.framework8910if [ -d \"$&#123;INSTALL_DIR&#125;\" ]11then12rm -rf \"$&#123;INSTALL_DIR&#125;\"13fi1415mkdir -p \"$&#123;INSTALL_DIR&#125;\"1617cp -R \"$&#123;DEVICE_DIR&#125;/\" \"$&#123;INSTALL_DIR&#125;/\"18#ditto \"$&#123;DEVICE_DIR&#125;/Headers\" \"$&#123;INSTALL_DIR&#125;/Headers\"1920lipo -create \"$&#123;DEVICE_DIR&#125;/$&#123;PROJECT_NAME&#125;\" \"$&#123;SIMULATOR_DIR&#125;/$&#123;PROJECT_NAME&#125;\" -output \"$&#123;INSTALL_DIR&#125;/$&#123;PROJECT_NAME&#125;\"2122#open \"$&#123;DEVICE_DIR&#125;\"23#open \"$&#123;SRCROOT&#125;/Products\"24fi","categories":[{"name":"Framework静态库","slug":"Framework静态库","permalink":"https://bondiblue.github.io/categories/Framework%E9%9D%99%E6%80%81%E5%BA%93/"}],"tags":[{"name":"OC","slug":"OC","permalink":"https://bondiblue.github.io/tags/OC/"}]},{"title":"iOS开发主要概念总结","slug":"iOS开发主要概念总结","date":"2019-08-24T02:12:40.000Z","updated":"2019-08-24T07:13:20.000Z","comments":true,"path":"2019/08/24/iOS开发主要概念总结/","link":"","permalink":"https://bondiblue.github.io/2019/08/24/iOS%E5%BC%80%E5%8F%91%E4%B8%BB%E8%A6%81%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/","excerpt":"","text":"一、用什么架构、有什么区别？（MVC、MVVM）1.MVC，即Model-View-Controller 它是苹果公司官方推荐的App开发架构，也是一般开发者最先遇到，最经典的架构。它把整个App分为三个部分：Model负责处理数据；View负责处理UI；Controller是View和Model的桥梁，它将数据从Model层传送到View层并展示出来，同时将View层的交互传到Model层以改变数据。它是应用的一种基本架构，主要目的是将不同的代码归并为不同的模块，做到低耦合、代码分配合理、易于扩展维护。 2.MVVM，MVVM衍生于MVC，是对 MVC 的一种演进，它促进了 UI 代码与业务逻辑的分离 在MVVM 中，view 和 view controller正式联系在一起，我们把它们视为一个组件。view 和 view controller 都不能直接引用model，而是引用视图模型（viewModel）。viewModel 是一个放置用户输入验证逻辑，视图显示逻辑，发起网络请求和其他代码的地方。使用MVVM会轻微的增加代码量，但总体上减少了代码的复杂性。 3.MVVM是MVC的升级版，完全兼容当前的MVC架构 MVVM虽然促进了UI 代码与业务逻辑的分离，一定程度上减轻了ViewController的臃肿度，但是View和ViewModel之间的数据绑定使得 MVVM变得复杂和难用了，如果我们不能更好的驾驭两者之间的数据绑定，同样会造成Controller 代码过于复杂，代码逻辑不易维护的问题。 二、解释一下多线程1.OC中多线程根据封装程度可以分为三个层次：NSThread、GCD和NSOperation 2.NSThread，NSThread是封装程度最小最轻量级的，使用更灵活，但要手动管理线程的生命周期、线程同步和线程加锁等，开销较大 3.GCD(Grand Central Dispatch)，又叫大中央调度，是 Apple 开发的一个多核编程的较新的解决方法 它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。提供了简洁的C语言接口，使用更加简单高效，也是苹果推荐的方式可以自动管理线程的生命周期（创建线程、调度任务、销毁线程）可用于多核的并行运算会自动利用更多的 CPU 内核（比如双核、四核）只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码主要是一些同步执行、异步执行、串行队列、并行队列将”任务”(block)添加到 队列(串行/并发/主队列/全局队列]),并且指定执行任务的函数(同步/异步)一次执行延迟执行 4.NSOperation，NSOperation是一个抽象类，不能直接使用，其目的就是为了定义子类共有的方法和属性 NSOperation、NSOperationQueue 是基于 GCD 更高一层的封装，完全面向对象。但是比 GCD 更简单易用、代码可读性也更高其子类有两个：NSInvocationOperation、NSBlockOperation本质上就是GCD的并发队列，就是异步执行任务 三、RunTime1.Runtime是属于Object-C的底层，是一套比较底层的纯C语言API，属于C语言库 2.在我们平时编写的Object-C代码中, 程序运行过程时, 其实最终都是转成了Runtime的C语言代码, Runtime算是Object-C的幕后工作者 3.静态语言： 如C语言，编译阶段就要决定调用哪个函数，如果函数未实现就会编译报错 动态语言： 如OC语言，编译阶段并不能决定真正调用哪个函数，只要函数声明过即使没有实现也不会报错。OC是一门动态语言，就是因为它总是把一些决定性的工作从编译阶段推迟到运行时阶段。OC代码的运行不仅需要编译器，还需要运行时系统(Runtime Sytem)来执行编译后的代码。 4.Runtime 实际上是一个库，这个库使我们可以在程序运行时动态的创建对象、检查对象，修改类和对象的方法 5.消息（方法）传递、消息转发 6.关联对象(Objective-C Associated Objects)给分类增加属性 7.魔法(Method Swizzling)方法添加和替换 在 Objective-C 的运行时中，每个类有两个方法都会自动调用。+load 是在一个类被初始装载时调用，+initialize 是在应用第一次调用该类的类方法或实例方法前调用的。两个方法都是可选的，并且只有在方法被实现的情况下才会被调用。 1@implementation ViewController23+ (void)load &#123;4 static dispatch_once_t onceToken;5 dispatch_once(&amp;onceToken, ^&#123;6 Class class &#x3D; [self class];7 SEL originalSelector &#x3D; @selector(viewDidLoad);8 SEL swizzledSelector &#x3D; @selector(jkviewDidLoad);9 10 Method originalMethod &#x3D; class_getInstanceMethod(class,originalSelector);11 Method swizzledMethod &#x3D; class_getInstanceMethod(class,swizzledSelector);12 13 &#x2F;&#x2F;judge the method named swizzledMethod is already existed.14 BOOL didAddMethod &#x3D; class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));15 &#x2F;&#x2F; if swizzledMethod is already existed.16 if (didAddMethod) &#123;17 class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));18 &#125;19 else &#123;20 method_exchangeImplementations(originalMethod, swizzledMethod);21 &#125;22 &#125;);23&#125;2425- (void)jkviewDidLoad &#123;26 NSLog(@&quot;替换的方法&quot;);27 28 [self jkviewDidLoad];29&#125;3031- (void)viewDidLoad &#123;32 NSLog(@&quot;自带的方法&quot;);33 34 [super viewDidLoad];35&#125;3637@end 8.KVO的实现 全称是Key-value observing，翻译成键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。 9.实现字典和模型的自动转换(MJExtension) 原理描述：用runtime提供的函数遍历Model自身所有属性，如果属性在json中有对应的值，则将其赋值。核心方法：在NSObject的分类中添加方法。 10.实现NSCoding的自动归档和自动解档 原理描述：用runtime提供的函数遍历Model自身所有属性，并对属性进行encode和decode操作。核心方法：在Model的基类中重写方法。 四.RunLoop1.RunLoop RunLoop是多线程的法宝，即一个线程一次只能执行一个任务，执行完任务后就会退出线程。主线程执行完即时任务时会继续等待接收事件而不退出。非主线程通常来说就是为了执行某一任务的，执行完毕就需要归还资源，因此默认是不运行RunLoop的； 2.每一个线程都有其对应的RunLoop，只是默认只有主线程的RunLoop是启动的，其它子线程的RunLoop默认是不启动的，若要启动则需要手动启动 3.在一个单独的线程中，如果需要在处理完某个任务后不退出，继续等待接收事件，则需要启用RunLoop 4.NSRunLoop提供了一个添加NSTimer的方法，可以指定Mode，如果要让任何情况下都回调，则需要设置Mode为Common模式 5.保证线程的长时间存活 6.保证NSTimer在视图滑动时，依然能正常运转 五.常用的设计模式1.单例模式（Singleton）: 此模式保证对于一个特有的类，只有一个公共的实例存在。它一般与懒加载一起出现，只有被需要时才会创建。单例模式的例子有UserDefaults、UIApplication、UIScreen； 2.观察者模式（Observer）: 它定义对象之间的一种一对多的依赖关系，每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。在iOS中的典型实现是NotificationCenter和KVO；KVO,Key-Value Observer,即键值观察。它是一种没有通知中心的观察者模式的实现方式。一个主体对象管理所有依赖于它的观察者对象，并且在自身状态发生改变时主动通知观察者对象。它的具体实现步骤如下。（1）注册观察者（2）更改主题对象属性的值，即触发发送更改的通知。（3）在制定的回调函数中，处理收到的更改通知。 六.项目的优化快：使用时避免出现卡顿，响应速度快，减少用户等待的时间，满足用户期望。稳：不要在用户使用过程中崩溃和无响应。省：节省流量和耗电，减少用户使用成本，避免使用时导致手机发烫。小：安装包小可以降低用户的安装成本。 1.重用问题： 如UITableViewCells、UICollectionViewCells、UITableViewHeaderFooterViews设置正确的reuseIdentifier，充分重用；尽量把views设置为不透明：当opque为NO的时候，图层的半透明取决于图片和其本身合成的图层为结果，可提高性能； 2.不要使用太复杂的XIB/Storyboard： 载入时就会将XIB/storyboard需要的所有资源，包括图片全部载入内存，即使未来很久才会使用。那些相比纯代码写的延迟加载，性能及内存就差了很多； 3.选择正确的数据结构： 学会选择对业务场景最合适的数组结构是写出高效代码的基础。比如，数组: 有序的一组值。使用索引来查询很快，使用值查询很慢，插入/删除很慢。字典: 存储键值对，用键来查找比较快。集合: 无序的一组值，用值来查找很快，插入/删除很快。 4.延迟加载： 对于不应该使用的数据，使用延迟加载方式。对于不需要马上显示的视图，使用延迟加载方式。比如，网络请求失败时显示的提示界面，可能一直都不会使用到，因此应该使用延迟加载。 5.数据缓存： 对于cell的行高要缓存起来，使得reload数据时，效率也极高。而对于那些网络数据，不需要每次都请求的，应该缓存起来，可以写入数据库，也可以通过plist文件存储，例如个人信息的一些数据，也许会有好几个页面会用到，那么就把数据存入本地，使用的时候根据需要可以直接从本地进行加载。 6.不要阻塞主线程，主线程主要做以下几个方面工作： UI 生命周期控制、系统事件处理、消息处理、界面布局、界面绘制、界面刷新，除此之外，应该尽量避免将其他处理放在主线程中，特别复杂的数据计算和网络请求等。 7.处理内存警告 在app delegate中使用applicationDidReceiveMemoryWarning的方法;注册并接收 UIApplicationDidReceiveMemoryWarningNotification的通知; 8.选择正确的数据存储选项 9.重用和延迟加载(lazy load) Views 更多的view意味着更多的渲染，也就是更多的CPU和内存消耗。不要一次创建所有的subview，而是当需要时才创建。 10.尽量把views设置为透明 如果你有透明的Views你应该设置它们的opaque属性为YES。原因是这会使系统用一个最优的方式渲染这些views。在相对比较静止的画面中，设置这个属性不会有太大影响。然而当这个view嵌在scroll view里边，或者是一个复杂动画的一部分，不设置这个属性的话会在很大程度上影响app的性能。 七、KVC、KVO1.键值编码是一种间接访问对象的属性使用字符串来标识属性，而不是通过调用存取方法，直接或通过实例变量访问的机制，非对象类型的变量将被自动封装或者解封成对象，很多情况下会简化程序代码 2.KVC的缺点： 一旦使用 KVC 你的编译器无法检查出错误,即不会对设置的键、键路径进行错误检查,且执行效率要低于合成存取器方法和自定的 setter 和 getter 方法。因为使用 KVC 键值编码,它必须先解析字符串,然后在设置或者访问对象的实例变量。 3.键值观察机制是一种能使得对象获取到其他对象属性变化的通知 ，极大的简化了代码 4.实现 KVO 键值观察模式,被观察的对象必须使用 KVC 键值编码来修 改它的实例变量,这样才能被观察者观察到 因此，KVC是KVO的基础。 5.注册观察者(注意：观察者和被观察者不会被保留也不会被释放) 1- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath 2options:(NSKeyValueObservingOptions)options 3context:(void *)context; 6.接收变更通知 1- (void)observeValueForKeyPath:(NSString *)keyPath2ofObject:(id)object change:(NSDictionary *)change context:(void *)context; 7.移除对象的观察者身份 1- (void)removeObserver:(NSObject *)observer2forKeyPath:(NSString *)keyPath; 8.KVO中谁要监听谁注册，然后对响应进行处理，使得观察者与被观察者完全解耦。KVO只检测类中的属性，并且属性名都是通过NSString来查找，编译器不会检错和补全，全部取决于自己 八、Block、通知、代理1.代理 是一种回调机制，且是一对一的关系，Delegate需要定义协议方法，代理对象实现协议方法，并且需要建立代理关系才可以实现通信； 2.通知 是一对多的关系，一个对向所有的观察者提供变更通知； 3.效率： Delegate比NSNOtification高； 4.Block 一般是一对一的通信； Block更加简洁，不需要定义繁琐的协议方法，但通信事件比较多的话，建议使用Delegate； 九、AFNetWorking底层原理1.AFHTTPRequestOperationManager： 内部封装的是 NSURLConnection, 负责发送网络请求, 使用最多的一个类。(3.0废弃) 2.AFHTTPSessionManager： 内部封装是 NSURLSession, 负责发送网络请求,使用最多的一个类。 2.AFNetworkReachabilityManager： 实时监测网络状态的工具类。当前的网络环境发生改变之后,这个工具类就可以检测到。 3. AFSecurityPolicy： 网络安全的工具类, 主要是针对 HTTPS 服务 4.AFURLRequestSerialization： 序列化工具类,基类。上传的数据转换成JSON格式(AFJSONRequestSerializer).使用不多。 6). AFURLResponseSerialization： 反序列化工具类;基类.使用比较多。 7.AFJSONResponseSerializer: JSON解析器,默认的解析器。 8.AFHTTPResponseSerializer: 万能解析器; JSON和XML之外的数据类型,直接返回二进制数据.对服务器返回的数据不做任何处理。 9.AFXMLParserResponseSerializer: XML解析器; 10.Scoket连接和HTTP连接的区别1.HTTP连接： 短连接，客户端向服务器发送一次请求，服务器响应后连接断开，节省资源。服务器不能主动给客户端响应（除非采用HTTP长连接技术），iPhone主要使用类NSURLConnection 2.Socket连接： 长连接，客户端跟服务器端直接使用Socket进行连接，没有规定连接后断开，因此客户端和服务器段保持连接通道，双方可以主动发送数据，一般多用于游戏Socket默认连接超时时间是30秒，默认大小是8K（理解为一个数据包大小） 十一、isa指针1.在 ios 开发中，类也是一个对象，我们称之为类对象， 所有对象中，包含实例对象和类对象，都含有一个isa 指针 实例对象的isa指针， 指向他的类对象，类对象的isa 指针， 指向他的元类。 2.系统判断一个对象属于哪个类，也是通过这个对象的isa指针的指向来判断 3.对象中的成员变量，存储在对象本身，对象的实例方法，存储在他的isa 指针所指向的对象中 即：减号方法存储在类对象中，类方法存储在类对象isa所指向的元类中，成员变量的值储存在对象中。 4.对象在调用减号方法的时候，系统会在对象的isa指针所指向的类对象中寻找方法，这一段在kvo的实现原理中就能看到，kvo的实现原理就是系统动态的生成一个类对象，这个类是监听对象的类的子类，在生成的类中重写了监听属性的set方法，实现对set方法的监听，之后将监听对象的isa指针指向系统动态生成的这个类，当监听对象调用set方法时，由于监听对象的isa指针指向的是刚刚动态生成的类，所以在其中找的的set方法也是重写过有监听功能的set方法，这就是kvo的实现原理。同理，我们也可以通过rutime中的方法设置某个对象isa指针指向的类对象，让对象调用一些原本不属于他的方法 十二、H5、CSS、JavaScript十三、WebView，JS和原生的交互iOS8.0之后，苹果推荐使用WebKit框架中的WKWebView来加载网页，使用WKWebViewConfiguration来配置JS交互。网页切换 1[_webView goBack]; &#x2F;&#x2F;页面后退23[_webView goForward]; &#x2F;&#x2F;页面前进45[_webView reload]; &#x2F;&#x2F;刷新当前页面 JavaSript调用OC 主要依靠WKScriptMessageHandler协议类、WKUserContentController其中:WKUserContentController对象负责注册JS方法，设置处理接收JS方法的代理，代理遵守WKScriptMessageHandler，实现捕捉到JS消息的回调方法。 1、配置与JavaScript的交互 用WKWebViewConfiguration来配置JS交互 2、使用WKUserContentController，用来做 原生与JavaScript的交互管理 3、使用协议类WKScriptMessageHandler，用来处理监听JavaScript方法从而调用原生OC方法。（和WKUserContentController搭配使用） 4、通过 接收JS传出消息的name 进行捕捉的回调方法 ps：遵守WKScriptMessageHandler协议，代理是由WKUserContentControl设置 OC调用JavaSript 使用WKUserScript，执行自定义的JavaScript代码 WKWebView涉及的代理方法 WKNavigationDelegate协议 主要处理一些跳转、加载处理操作 十四、iOS事件响应机制iOS的事件响应必须是UIResponder对象及其子类，我们Command查看层级关系不难发现，UITextView，UILabel，UIButton等控件他们都是UIResponder的子类。这也是他们能够响应事件的基础。 当触摸事件发生时，首先系统通过hitTest方法找到能最合适的view，所谓最合适的view 其实就是 触摸事件 他的触摸点是否在这个View上，一个点可能在多个叠加的视图上，所以系统会找到所有的view（点所在的view），方向是从底下往上，所以判断点的顺序就是父view-&gt;子view-&gt;子view的子view，这样遍历下去，配合pointconvert方法和pointinside方法去判断这个点是否在这个view上，在就遍历他的子view，直到不满足条件。 事件的传递 系统把事件加入到一个由UIApplication管理的事件队列中之所以加入队列而不是栈是因为队列先进先出，意味着先产生的事件，先处理 然后，事件会按照UIApplication -&gt; UIWindow -&gt; SuperView -&gt; SubView的顺序不断的检测 而检测就是靠两个方法hitTest与pointInside 十五、iOS内存管理1.首先，严格的内存管理，能够是我们的应用程在性能上有很大的提高，如果忽略内存管理，可能导致应用占用内存过高，导致程序崩溃 2.内存管理方式主要分为3种: ARC（自动内存计数）、MRC（手动内存计数）、内存池 3.自动内存计数和手动内存计数都是用计数管理 每个对象都有一个引用计数器，每个新对象的计数器是1，当对象的计数器减为0时，就会被销毁；通过retain可以让对象的计数器+1、release可以让对象的计数器-1；保证任何时候指向对象的指针个数和对象的引用计数相同，多一个指针指向这个对象这个对象的引用计数就加1，少一个指针指向这个对象这个对象的引用计数就减1。没有指针指向这个对象对象就被释放了。 4.内存管理遵循谁使用、谁创建；谁引用、谁管理的原则 5.被存入到自动释放池内的对象，当自动释放池被销毁时，会对池内的对象全部做一次release操作 6.自动释放池，什么时候创建? 程序刚启动的时候，也会创建一个自动释放池 产生事件以后，运行循环开始处理事件，就会创建自动释放池 7.什么时候销毁的? 程序运行结束之前销毁 事件处理结束以后，会销毁自动释放池 还有在池子满的时候，也会销毁","categories":[{"name":"总结","slug":"总结","permalink":"https://bondiblue.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://bondiblue.github.io/tags/iOS/"}]},{"title":"Git使用方法总结","slug":"Git使用方法总结","date":"2019-06-08T02:12:40.000Z","updated":"2019-06-10T08:11:20.000Z","comments":true,"path":"2019/06/08/Git使用方法总结/","link":"","permalink":"https://bondiblue.github.io/2019/06/08/Git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/","excerpt":"","text":"Git使用https协议，本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，每次pull,push都要输入密码，使用Git协议，使用ssh秘钥，可以省去每次输密码 大概需要三个步骤：一、本地生成密钥对；二、设置github上的公钥；三、修改git的remote url为git协议。 1//git配置信息查询2git config --list34//全局配置Git账户5git config --global user.name \"用户名\"6git config --global user.email xxx账号邮箱@xxx.com78//在某个Git仓库里，若是不同Git账号的话，去掉--global重新配置9git config user.name \"用户名\"10git config user.email xxx账号邮箱@xxx.com1112//通过终端命令创建ssh key13ssh-keygen -t rsa -C \"xxxx账号邮箱@xx.com\"1415//若没有创建过ssh key，会要求确认路径和输入密码，默认的一路回车就行。成功的话会在~/下生成.ssh文件夹，进去，打开id_rsa.pub，复制里面的key1617//终端查看.ssh/id_rsa.pub文件: 18open .ssh/id_rsa.pub1920//回车后，就会新弹出一个终端，然后复制里面的key,2122//或者用cat命令查看:23cat .ssh/id_rsa.pub2425//登录GitHub，点击Settings，添加ssh key262728//添加ssh key完成后链接验证29ssh -T git@github.com30//如果，看到：31//Hi username! You've successfully authenticated, but GitHub does not # provide shell access.32//就表示你的设置已经成功了。3334//提交本地项目到GitHub3536//1）在GitHub上新创建一个 repository或者Start a Project3738//2)Clone工程到本地一个空文件夹中3940//3)在Xcode中新创建一个工程，保存的路径为刚刚克隆下来的文件夹下4142//4)提交修改，首先切换到clone下来的的文件路径下：43 然后输入:4445//文件添加到仓库（.代表提交所有文件）,用命令git add告诉Git，把文件添加到仓库：46git add .47git add “文件名” “文件名” 4849//查看仓库当前文件提交状态（A：提交成功；AM：文件在添加到缓存之后又有改动）50git status -s5152//从Git的暂存区提交版本到仓库，参数-m后面的字符串为本次提交的备注信息，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。53git commit -m \"First Commit\"54//上传到github55git push56或57git push origin master5859//修改本地的ssh remote url，不用https协议，改用git 协议6061//可以用git remote -v 查看你当前的remote url62$ git remote -v63origin https://github.com/someaccount/someproject.git (fetch)64origin https://github.com/someaccount/someproject.git (push)65//可以看到是使用https协议进行访问的。6667//使用浏览器登陆github，上面的ssh协议相应的url。类似如下：68git@github.com:someaccount/someproject.git6970//这时可以使用 git remote set-url 来调整你的url。71git remote set-url origin git@github.com:someaccount/someproject.git7273完了之后，再用 git remote -v 查看一下。 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 今天提交git仓库的时候，遇到了如截图所示的问题，提示Your branch is up-to-date with ‘origin/master’. 查了些资料后，发现其根本原因是版本分支的问题 这时候我们就需要新建一个分支1$ git branch newbranch 然后检查分支是否创建成功1$ git branch 会有如下提示（前面的*代表的是当前你所在的工作分支） 然后切换到你的新分支1$ git checkout newbranch 如果不放心，还可以 $ git branch确认下 然后将你的改动提交到新分支上1$ git add . 2$ git commit -m \"18.03.01\" 然后git status检查是否成功 然后切换到主分支1$ git checkout master 然后将新分支提交的改动合并到主分支上1$ git merge newbranch 然后就可以push代码了1$ git push -u origin master 最后还可以删除这个分支1$ git branch -D newbranch 分支在实际中有什么用呢？ 假设你准备开发一个新功能，但需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。 现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。 但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件，大大提高了开发效率。","categories":[{"name":"总结","slug":"总结","permalink":"https://bondiblue.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://bondiblue.github.io/tags/Git/"}]},{"title":"消费者心理学：三个趣味经济学原理","slug":"消费者心理学：三个趣味经济学原理","date":"2019-01-23T03:12:40.000Z","updated":"2019-01-23T03:12:40.000Z","comments":true,"path":"2019/01/23/消费者心理学：三个趣味经济学原理/","link":"","permalink":"https://bondiblue.github.io/2019/01/23/%E6%B6%88%E8%B4%B9%E8%80%85%E5%BF%83%E7%90%86%E5%AD%A6%EF%BC%9A%E4%B8%89%E4%B8%AA%E8%B6%A3%E5%91%B3%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86/","excerpt":"","text":"消费者心理学：三个趣味经济学原理 降价、节约、免费，在互联网背景下成为不少商家打天下的三板斧。从不少国内企业的实践来看，效果并不那么理想。价格是商品价值实现的重要依据，文章中作者针对虚荣效应、节约悖论和免费经济学的三个领域的现象做出解释，在产品定价和营销等方面给出了建议。 价格越低为什么不但不好卖，反而价格越高越好卖，为什么大手大脚的浪费反而可以拯救经济?为什么免费未必就是最好的，这些经济学原理背后又有哪些逻辑在支撑，让我去探讨一下这些好玩的经济学吧。 价格越高越好卖——虚荣效应 富人们一般不喜欢大众模仿他们的消费行为，这种情况就叫做虚荣效应(snob effect)。虚荣效应具体是指购买商品的时候追求与众不同的个性的现象。在韩国也称为白鹭效应。因为对于某些人来说，即便是自己原本长期使用的商品， 一旦成为大众化商品的话，他们就会将其更换为并不广为人知的新商品，就好像如果一个地方的乌鸦大量涌进，白鹭就会离开一样。 1950 年，美国经济学家哈维莱宾斯坦(Harvey Leibenstein)同时发布了随着其他人的使用与否增加购买意图的从众效应(bandwagon effect)和随着其他人的使用与否减少购买意图的虚荣效应。如果某种商品成为广为人知的人气商品，则人人都想购买，这种现象就叫从众效应。英文中 bandwagon指游行队列中领头的乐队车辆，人们在大街上看到bandwagon就认为会有有意思的事情而无条件地跟随。从众效应就是指这种不细加考 虑就跟着别人做的消费行为。虚荣效应则是指与从众效应正好相反的现象。 但是，虚荣效应并不止于不购买大众消费品，也可以解释为对非大众性商品的购买需求，简单地说虚荣效应就是对高档商品的个性追求倾向。 虚荣效应主要有以下两种表现。 第一，高档商品刚上市的时候迅速购买。这是因为，在这一瞬间并不是每个人都能享受到消费高档商品的荣誉。 第二，不论之前如何热情赞美的商品，一旦其市场占有率达到一般大众都可以消费的水平就不再继续购买。这是因为人人都能购买使用的商品既不会让人感到荣誉，也不会有高档的感觉。 不过，这样的虚荣效应并不是在所有商品上都会出现。 商品越是高档，越是以个人消费为主的时候，虚荣效应越是明显。如果不是以个人消费为主，购买商品是为了向外部展示的时候，即便其价格高昂，也可能出现价格越高需求反而有所增加的从众效应。 如果认为商品目标市场中有较大的可能性出现虚荣效应的话，在建立营销计划时有必要留意以下三点。 第一，相对于商品的市场占有率，更重视其终生价值(life time value)。也就是说，在市场战略的选择方面，相较于扩大客户数量，更注重把焦点集中在维持原有客户上，因为如果只关注眼前的利益而把重点放在市场扩张 上而忽视原有客户的话，总有一天会连原有客户都会离开。不仅如此，从某个时点开始，市场战略不能只停留在不再扩充新用户，还要做防止新用户流入的限制性营 销(demarketing)才行。 第二，要绝对回避价格竞争。降低价格会诱发两方面的问题。对价格比较敏感的一般大众会购买降价后的该商品，而这会降低商品的稀少性，导致现有客户的离开。而且，在市场中价格有时会成为商品品质的一种指标，所以价格的降低很容易导致商品品质的下降。 第三，作为市场后入者，要尽量避免如”我也要做”(me too)形式的商业推进。因为具有虚荣效应的市场看起来会有很好的收益率而且竞争者也不多，但是，新的竞争者参与市场的同时，就有可能导致市场本身发生崩 溃。新竞争者的参与会增加消费，但因为虚荣效应，原来的客户可能会选择离开市场。原来的商家因为之前已经享受了高收益，所以还可以收回投资成本，而新加入 的竞争者就只能蒙受巨大的损失。 活跃在19世纪后期和20世纪初期的美国制度学派经济学家索尔斯坦凡勃伦(Thorstein Bunde Veblen)在其着作《有闲阶级论》中指出，虽然一般来说商品价格的上涨会导致需求的降低，但在某些商品上却存在着价格上涨反而导致需求增加的现象。通 常在价格昂贵的高档品牌上出现的这种现象被称做凡勃伦效应(Veblen effect)，而具有这种特性的商品就叫做凡勃伦商品(Veblen goods)。 相反，价格下降的时候需求也下降的商品称为吉芬商品(Giffen goods)。通常价格下降会导致需求上升，但是如果价格的下降导致的收入上升效果更大的话，就会降低对该商品的需求。实际上这种情况非常少见，只有在收 入中对该商品的消费支出占整体支出比例较大的情况下才会出现这种现象。 落后国家模仿发达国家的消费模式，或者低收入者模仿高收入者的消 费行为现象被经济学家杜森伯里(Dusenberry)称为示范效应(demonstration effect)。消费者的行为不受自身绝对收入的影响，而是取决于相对于周围其他人的收入，自己的收入处于什么水平。这就是相对收入假说。示范效应的核心 如下：社会中有从低档到高档多种商品的时候，想要更高档的商品是人之常情，而能够更多地接触到有较高社会地位者的人，他们的这种需求会更大。 购买某种商品后，消费需求会向和该商品有关联的其他商品延伸。这种延伸效应就是狄德罗效应(Diderot effect)。狄德罗是18世纪法国启蒙思想家组织百科全书派的哲学家。有一天，狄德罗买了一件新的家居服，之后就觉得屋内的家具都显得很旧，于是为了 能跟家居服相匹配他换了新的书桌，然后换掉了壁挂的装饰品，最终换掉了所有家具。这就是狄德罗效应，相信这会是受装修业者欢迎的一种效应。 大手大脚的浪费能拯救经济——节约悖论 我们都知道，如果消费超过收入，就没有余钱可以储蓄，也就无法积累资金，最终只能过贫穷的生活。所以，为了成为富人我们会努力工作，有时候也会变成小气鬼，为了能储蓄更多钱而努力。 这个原理对于个人是适用的，但是对于国家整体经济是否也适用呢?如果所有国民都变成小气鬼，这个国家真的能够变得更加富强吗?答案是否定的，尤其是在经济不景气的时候。让我们看看其原因何在。 一旦经济进入不景气，基于对未来的担忧，人们会选择更多的储蓄进而减少消费。可是如果所有人都减少消费的话，企业的销售额就会降低，库存就会增加。随之 而来的是企业只能降低生产减少雇用，而企业员工的收入就会减少。那么，对未来的担忧就会强化，人们会更加坚定地减少消费增加储蓄，于是整体经济就会陷入愈 发不景气的恶性循环中。 这就出现了以个人的角度看储蓄是合理的行为，而从整体经济上又是不合理的悖论。这称为节约悖论(paradox of thrift)。在逻辑学上对个体适合丶对整体不适合的现象叫做合成谬误(fallacy of composition)，节约悖论正是属于这种合成谬误。 20世纪30年代，全世界陷入严重经济衰退的时候，出现了这样的节约悖论。 面对不景气的局面，商家都减少了消费，于是经济陷入更大的不景气中。洞察这一悖论状况的英国经济学家约翰梅纳德凯恩斯开出了如果家庭不能扩大消费的话，政 府也应该承担财政赤字、扩大政府支出的处方。因为只有这样，整体经济的需求才会扩大，企业的销售额才会增加，生产和雇用状况也才能够得到改善。最终通过增 加家庭收入的方式扩大家庭的消费。正因为凯恩斯透彻地了解个体储蓄和整体储蓄之间的区别，才有可能拿出这样的解决方案。凯恩斯在他的《就业、利息和货币通 论》的书中就指出：在经济不景气的时候，消费就是美德，储蓄就是恶行。 不过，凯恩斯并不是第一个认识到这种状况的人。比凯恩斯还早 200多年的18世纪初，伯纳德曼德维尔(Bernard Mandeville)就已经看穿了这种现象。让我们看看出生在荷兰的医生兼英国自由主义思想家的伯纳德曼德维尔于1714年为了讽刺英国社会而写的《蜜 蜂的寓言》(The Fable of the Bees)中的讽刺诗《嗡嗡的蜂巢》(The Grumbling Hive)吧。这首诗的副标题为”个人的恶行或公共的利益”。 从前，有一个非常繁荣的蜜蜂王国。国王和贵族们虽然欠下了巨大的债务，但是依然建设豪华的宫殿和别墅，穿着华丽的服装，每天用山珍海味举办各种派对。 这个国家用强有力的军队侵略周边国家以扩大自己的殖民地。当很多士兵在战场上牺牲的时候，大部分将军躲在后方的地洞中。不过每次凯旋的时候他们总是像英雄一样站在最前面，而勋章也都是归他们所有。 各种裁判的结果并不是取决于是非的判断，而是取决于给法官和律师的贿赂。商品的订单总是接连不断，产业链从上到下都业务不断，所有人都能尽情享受奢华的生活。 有一天恶行盛行的蜜蜂王国里突然出现了一位高僧，表示所有人都应该悔改，并开始念诵咒语。于是蜜蜂们认识到了自己的过失，发誓要过清廉正直的生活。王后 和贵族们把宫殿和奢华服装都卖掉偿还了债务，开始了一年到头只穿一件衣服的简朴生活，解散了军队，关闭了剧场。因为每个人都捍卫正直的生活，所以裁判也变 成了没有必要的事情了。 于是，派对和演出消失了，制作豪华服装的裁缝和厨师丶木工丶石匠丶雕刻师丶演员等纷纷失业。蜜蜂们甚至觉得生活在建筑里也是一种奢侈，都搬到树洞中居住。 后来，原殖民地的异邦蜜蜂们大举进攻蜜蜂王国，将所有善良的蜜蜂都抓去当了奴隶，从此善良蜜蜂们就只能每天过着战战兢兢的悲惨生活。 曼德维尔想通过这个故事传达什么样的信息呢?他主张单纯靠具备好的德行是无法让国民过上好生活的，并且认为通过节约和储蓄，个人虽然可以增加财富，但在 国家层面上这个逻辑是完全行不通的。他以禁欲和利他心是伪善的，普遍认为是恶行的欲望正是经济发展的原动力这样的观点正面挑战了基督教的伦理观。谴责他的 人因为他公开拥护恶行而用谐音称他为人间恶魔(Man-Devil)。 200年后的凯恩斯非常喜欢曼德维尔的这首诗，为了强调20世纪30年代的经济衰退的原因是有效需求的不足，凯恩斯在其代表作《就业丶利息和货币通论》中引用了曼德维尔的《蜜蜂的寓言》。 1666年，伦敦发生大火灾，整个英国陷入危机。但是曼德维尔曾乐观地表示，虽然伦敦大火灾是巨大的灾难，但是在重建伦敦的过程中扩大的有效需求会激活英国经济。 现在，电视和报纸中还会经常报道经济不景气中老百姓缩衣节食，而富人们大肆购买昂贵的名牌货，过着奢华生活的现状，指责富人们的消费行为。但是，从节约悖论上看，富人们的这种消费能够增加整体需求，反而是在帮助经济尽快恢复。 如果商家不能扩大消费的话，政府也应该出面扩大政府支出，为企业提供投资优惠条件，而且要努力吸引外国投资者和观光客，增加投资和消费。只有这样才能形成良性循环最终让经济景气起来。 免费未必就好——免费经济学 “世上没有免费的午餐”是1976年获得诺贝尔经济学奖的着名经济学家米尔顿弗里德曼(Milton Friedman)常说的一句话。 有的信息粗看之下似乎是免费的，实际上经过了解后发现并不是免费的意思;或者可以解释为免费后面隐藏着某种诱饵，还可以理解为不要期待不付出代价的免费东西。就像”免费的奶酪只存在于捕鼠器上”的俄罗斯谚语一样，对免费的东西保持警惕是亘古不变的道理。 不过，有真正免费的主张逐渐占了上风。就像劣币驱逐良币一样，免费驱逐收费的趋势得到了强化。英国的《经济学人》展望2008年的时候把这样的趋势命名为免费经济学(freeconomics)，将单词免费(free)和经济学(economics)合起来形成新词。 2007年唱片业发生了一个大事件。人气歌手普林斯(Prince)通过英国《星期日邮报》免费派送新专辑Planet Earth的CD，数量达到了300万张。听了唱片的人去演唱会的概率会更高一些，但是也没有一定如此的保障。当然，也可能是因为预料到即便不免费派送人 们也会进行非法复制和传播，所以才免费派送。总之，这真是一个令人震惊的做法。 韩国也有过类似的情况。2007年LG电子出品了具备MP3强化功能的高档音乐手机。世界级的音质专家马克李文森为手机安装了可以保证音响效果并且用手指可以灵活控制的操控键，利用高级听筒保证了MP3功能。这个手机中搭载了成诗京丶孙昊永等7名顶尖歌手的唱片。 在手机公司采用这样的免费战略之前，谷歌很早就提供了大空间的免费邮箱服务GMAIL,UCC网站youtube也提供了大容量的免费视频空间，网络电话服务商Skype也给消费者提供了免费的长途电话丶国际长途业务。 从很早开始，酒吧里就免费提供下酒小菜，为什么这种策略会奏效呢?这是因为在提供了花生等下酒小菜的时候，人们喝酒的概率会变大。更进一步的，美国的酒 吧里清水也是收费的，理由很简单，水喝多了喝酒的概率就会降低。简单说下酒小菜和酒是辅助关系，而清水和酒则是竞争关系。酒吧主人们通过过去丰富的经验， 一直采用这样的销售策略。 看看我们周围，就能发现很多免费营销，地铁站前的免费报纸就是其中一种。曾经威胁到日报和体育报纸的免费报纸 因为有很多读者，所以可以从广告收入上获得高收益。人气差的免费报纸会因为得不到足够的广告收入而被淘汰，这样的话，幸存下来的免费报纸就可以逐步占据更 加有利的位置。越是资金实力雄厚的公司，在这种免费竞争中能够生存下来的概率就越大。因此，消费者也可能会面临因为垄断招致的损失。 免费经济市场的另一个弊端就是对资源的浪费。以免费报纸为例，因为免费派发给消费者，所以新闻纸会被大量浪费掉。大量生产大量消费的体制会导致能源的过度使用而招致地球变暖势头的加速。 企业经营专家中，几乎没有人不知道汤姆彼得斯(Tom Peters)的，他之所以如此有名是因为他于1982年和罗伯特沃特曼合着出版了《追求卓越》一书。有意思的是这本书出版之前，他们制作了1.5万部的 试读版免费派发给对此书有兴趣的读者。当然，这令出版社大吃一惊，因为它们认为这本书本来销量就不会很大，还免费派发这么多试读版。不过，这本书能够成为 超级畅销书也正是这个免费试读版的功劳。阅读了试读版后感受良多的读者在此书正式出版之后蜂拥购买，导致此书销量激增。托免费派发策略的福，汤姆彼得斯成 了超级畅销书作者丶顶级演讲家和顶级咨询专家。 韩国的公务员和企业家总是因为腐败问题受到指责，所以以往很普遍的请客吃饭 等现象现在大多被禁止了。因为在大多数情况下，这样的请客吃饭都是有所求的。因即时贴和透明胶带而着名的3M公司的道德经营就非常彻底，该公司企业道德规 定条例在礼品赠送的项目下面有这样一条：”给业务相关方提供的礼品每年不能超过50美元，咖啡和多纳圈除外。”所以，不用因免费的咖啡和多纳圈而产生罪恶 感。于是我们可以得出这样的结论：”没有免费的午餐，但是有免费的咖啡。” （来源：《最好用的101个经济法则》文/金敏周 翻译/权成光）","categories":[{"name":"经济学","slug":"经济学","permalink":"https://bondiblue.github.io/categories/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"}],"tags":[{"name":"经济学","slug":"经济学","permalink":"https://bondiblue.github.io/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"}]},{"title":"property的属性","slug":"property属性","date":"2018-10-17T01:08:40.000Z","updated":"2018-10-18T06:11:20.000Z","comments":true,"path":"2018/10/17/property属性/","link":"","permalink":"https://bondiblue.github.io/2018/10/17/property%E5%B1%9E%E6%80%A7/","excerpt":"","text":"学习iOS开发也已经半个月左右了，也尝试做简单的程序，但是遇到很多问题，总结下来就是：急于求成，总想着做一个东西出来，里面的东西也不懂，只知道把这个复制到代码中就OK了，现在发现基础很重要，所以在此对最基本的经常接触的合成存储器@property的weak nonatomic strong等属性总结一下： @property @synthesize关键字 1&#x2F;&#x2F;注意：其实就是用来替代setter和getter方法的。这两个关键字是编译器特性，让Xcode可以自动生成getter和setter的声明和实现。23&#x2F;&#x2F;property:属性;4&#x2F;&#x2F;synthesize:合成;56@property与@synthesize是成对出对出现的，可以自动生成某个类成员变量的存取方法。7在Xcode4.5以及以后的版本，@synthesize可以省略。 @property是在头文件.h中声明一个变量的setter和getter方法 1@property int age;2&#x2F;&#x2F;编译时遇到这一行，则自动扩展成下面两句：3-(void)setAge:(int)Age;4-(int)age; @synthesize是在m文件中定义setter和getter方法的实现 1@synthesize age&#x3D;_age;23&#x2F;&#x2F;相当于下面的代码：45-(void)setAge:(int)age6&#123;7 _age&#x3D;age;8&#125;9-(int)age10&#123;11 Return _age;12&#125; //atomic:原子;//nonatomic:非原子; 1.atomic与nonatomicatomic：默认是由该属性的，这个属性是为了保证程序在多线程情况，编译器会自动生成一些互斥加锁代码，避免该变量的读写不同步问题。 如果有多个线程同时调用setter的话，不会出现某一个线程执行setter全部语句之前，另一个线程开始执行setter情况，相当于函数头尾加了锁一样。 nonatomic：如果该对象无需考虑多线程的情况，请加入这个属性，这样会让编译器少生成一些互斥加锁代码，可以提高效率。 2.readwrite(读写)与readonly(只读)readwrite：这个属性是默认的情况，会自动为你生成存取器，既会生成getter方法，也会生成setter方法。readonly：只生成getter不会有setter方法。readwrite、readonly这两个属性的真正价值，不是提供供成员变量访问接口，而是控制成员变量的访问权限。 3.strong(强引用)与weak(弱引用)strong：强引用，也是我们通常说的引用，其存亡直接决定了所指向对象的存亡。如果不存在指向一个对象引用，并且此对象不在显示在列表中，则此对象会被从内存中释放。weak：弱引用，不决定对象的存亡。即使一个对象被持有无数个弱引用，只要没有强引用指向它，那么还是会被清除。strong与retain功能相似；weak与assign相似，只是当对象消失后weak会自动把指针变为nil //assign:分配//retain:保留 4.assign、copy、retainassign：默认类型，setter方法直接赋值，不进行任何retain操作，不改变引用计数。一般用来处理基本数据类型。retain：释放旧的对象（release）,将旧对象的值赋给新对象，再令新对象引用技术为1。我理解为指针的拷贝，拷贝一份原来的指针，释放原来指针指向的对象内容，再令指针指向新的对象内容。copy：与retain处理流程一样，先对旧值release,再copy出新的对象，retainCount为1。为了减少对上下文的依赖而引入的机制。我理解为内容的拷贝，向内存申请一块空间，把原来的对象内容赋给它，令其引用计数为1。对copy属性要特别注意：被定义有copy属性的对象必须要符合NSCopying协议，必须实现-(id)copyWithZone:(NSZone*)zone方法。也可以直接使用： 1//使用assign: 对基础数据类型 （NSInteger，CGFloat）和C数据类型（int, float, double, char, 等等）2//使用copy： 对NSString3//使用retain： 对其他NSObject和其子类 5.getter settergetter:是用来指定get方法的方法名setter:是用来指定set访问的方法名在@property的属性中，如果这个属性是一个BOOL值，通常我们可以用getter来定义一个自己喜欢的名字，例如: 1@property(nonatomic,assign,getter&#x3D;isValue) boolean value;2@property(nonatomic,assign,setter&#x3D;setIsValue) boolean value; 通俗理解retain、copy、assign区别1.假设你用malloc分配了一块内存，并且把它的地址赋给了指针a，后来你希望指针b也共享这块内存，于是你又把a赋值给（assign)了b。此时a和b指向同一块内存，请问当a不再需要这块内存，能否直接释放它？答案是否定的，因为a并不知道b是否还在使用这块内存，如果a释放了，那么b在使用这块内存的时候会引起程序crash掉。 2.了解到1中assign的问题，那么如何解决？最简单的一个方法就是使用引用计数（reference counting），还是上面的那个例子，我们给那块内存设一个引用计数，当内存被分配并且赋值给a时，引用计数是1。当把a赋值给b时引用计数增加到2。这时如果a不再使用这块内存，它只需要把引用计数减1，表明自己不再拥有这块内存。b不再使用这块内存时也把引用计数减1。当引用计数变为0的时候，代表该内存不再被任何指针所引用，系统可以把它直接释放掉。 3.上面两点其实就是assign和retain的区别，assign就是直接赋值，从而可能引起1中的问题，当数据为int，float等原生类型时，可以使用assign。retain就如2中所述，使用了引用计数，retain引起引用计数加1，release引起引用技术减1，当引用计数为0时，dealloc函数被调用，内存被收回。 4..atomic和nonatomic用来决定编译器的生成getter和setter是否为原子操作。在多线程环境下，原子操作是必要的，否则有可能引起错误结果。加了atomic，setter函数会变成下面这样： 1if(property !&#x3D; newValue)&#123;2 [property release];3 property&#x3D;[newValue retain];4&#125; 深入理解一下（包括autorelease）1.retain之后count加1 alloc之后count就是1，release就会调用dealloc销毁这个对象如果retain，需要release两次。通常在method中把参数赋给成员变量时需要retain.例如： 1&#x2F;&#x2F;classA有setName这个方法：2-(void)setName(ClassName *) inputName&#123;3 name&#x3D;inputName;4 [name retain];5&#x2F;&#x2F;此处retain,等同于[inputName retain]，count等于2&#125; 调用时： 1ClassName *myName&#x3D;[[ClassName alloc] init];2[[classA setName:myName]; 3&#x2F;&#x2F;retain count &#x3D;&#x3D; 24[myName release]; 5&#x2F;&#x2F;retain count&#x3D;&#x3D;1，在ClassA的dealloc中release name才能真正释放内存 2、autorelease更加tricky，而且很容易被它的名字迷惑。强调注意：autorelease不是garbage collection完全不同于Java中的GC，autorelease和作用域没有任何关系！autorelease 原理：a.先建立一个autorelease poolb.对象从这个autorelease pool里面生成c.对象生成 之后调用autorelease函数，这个函数的作用仅仅是在autorelease pool中做个标记，让pool记得将来release一下这个对象d.程序结束时，pool本身也需要rerlease, 此时pool会把每一个标记为autorelease的对象release一次 如果某个对象此时retain count大于1，这个对象还是没有被销毁上面这个例子应该这样写： 1ClassName *myName &#x3D; [[[ClassName alloc] init] autorelease];2&#x2F;&#x2F;标记为autorelease3[classA setName:myName]; 4&#x2F;&#x2F;retain count &#x3D;&#x3D; 25[myName release]; 6&#x2F;&#x2F;retain count&#x3D;&#x3D;1，注意，在ClassA的dealloc中不能release name，7&#x2F;&#x2F;否则release pool时会release这个retain count为0的对象，这是不对的 记住一点：如果这个对象是你alloc或者new出来的，你就需要调用release 如果使用autorelease，那么仅在发生过retain的时候release一次（让retain count始终为1）3、xcode 中的新标记 strong weakstrong 用来修饰强引用的属性；对应以前retain weak 用来修饰弱引用的属性；对应以前的assign","categories":[{"name":"总结","slug":"总结","permalink":"https://bondiblue.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"OC","slug":"OC","permalink":"https://bondiblue.github.io/tags/OC/"}]},{"title":"iOS底层原理总结 - 探寻OC对象的本质","slug":"iOS底层原理总结 - 探寻OC对象的本质","date":"2018-10-09T02:23:36.000Z","updated":"2018-10-09T07:12:22.000Z","comments":true,"path":"2018/10/09/iOS底层原理总结 - 探寻OC对象的本质/","link":"","permalink":"https://bondiblue.github.io/2018/10/09/iOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93%20-%20%E6%8E%A2%E5%AF%BBOC%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8/","excerpt":"","text":"转载自：iOS底层原理总结 对小码哥底层班视频学习的总结与记录。面试题部分，通过对面试题的分析探索问题的本质内容。 面试题：一个NSObject对象占用多少内存？ 探寻OC对象的本质，我们平时编写的Objective-C代码，底层实现其实都是C\\C++代码。 OC的对象结构都是通过基础C\\C++的结构体实现的。我们通过创建OC文件及对象，并将OC文件转化为C++文件来探寻OC对象的本质 OC如下代码 1#import &lt;Foundation/Foundation.h&gt;23int main(int argc, const char * argv[]) &#123;4 @autoreleasepool &#123;5 NSObject *objc = [[NSObject alloc] init];6 NSLog(@\"Hello, World!\");7 &#125;8 return 0;9&#125; 我们通过命令行将OC的mian.m文件转化为c++文件。 1clang -rewrite-objc main.m -o main.cpp // 这种方式没有指定架构例如arm64架构 其中cpp代表（c plus plus）2生成 main.cpp 我们可以指定架构模式的命令行，使用xcode工具 xcrun 1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp 2生成 main-arm64.cpp main-arm64.cpp 文件中搜索NSObjcet，可以找到NSObjcet_IMPL（IMPL代表 implementation 实现） 我们看一下NSObject_IMPL内部 1struct NSObject_IMPL &#123;2 Class isa;3&#125;;4// 查看Class本质5typedef struct objc_class *Class;6//我们发现Class其实就是一个指针，对象底层实现其实就是这个样子。 思考： 一个OC对象在内存中是如何布局的。 NSObjcet的底层实现，点击NSObjcet进入发现NSObject的内部实现 1@interface NSObject &lt;NSObject&gt; &#123;2#pragma clang diagnostic push3#pragma clang diagnostic ignored \"-Wobjc-interface-ivars\"4 Class isa OBJC_ISA_AVAILABILITY;5#pragma clang diagnostic pop6&#125;7@end 转化为c语言其实就是一个结构体 1struct NSObject_IMPL &#123;2 Class isa;3&#125;; 那么这个结构体占多大的内存空间呢，我们发现这个结构体只有一个成员，isa指针，而指针在64位架构中占8个字节。也就是说一个NSObjec对象所占用的内存是8个字节。到这里我们已经可以基本解答第一个问题。但是我们发现NSObject对象中还有很多方法，那这些方法不占用内存空间吗？其实类的方法等也占用内存空间，但是这些方法所占用的存储空间并不在NSObject对象中。 为了探寻OC对象在内存中如何体现，我们来看下面一段代码 1NSObject *objc = [[NSObject alloc] init]; 上面一段代码在内存中如何体现的呢？ 上述一段代码中系统为NSObject对象分配8个字节的内存空间，用来存放一个成员isa指针。 那么isa指针这个变量的地址就是结构体的地址，也就是NSObjcet对象的地址。 假设isa的地址为0x100400110，那么上述代码分配存储空间给NSObject对象，然后将存储空间的地址赋值给objc指针。 objc存储的就是isa的地址 objc指向内存中NSObject对象地址，即指向内存中的结构体，也就是isa的位置。 自定义类的内部实现1@interface Student : NSObject&#123;2 3 @public4 int _no;5 int _age;6&#125;7@end8@implementation Student910int main(int argc, const char * argv[]) &#123;11 @autoreleasepool &#123;1213 Student *stu = [[Student alloc] init];14 stu -&gt; _no = 4;15 stu -&gt; _age = 5;16 17 NSLog(@\"%@\",stu);18 &#125;19 return 0;20&#125;21@end 按照上述步骤同样生成c++文件。并查找Student，我们发现Student_IMPL 1struct Student_IMPL &#123;2 struct NSObject_IMPL NSObject_IVARS;3 int _no;4 int _age;5&#125;; 发现第一个是 NSObject_IMPL的实现。而通过上面的实验我们知道NSObject_IMPL内部其实就是Class isa 那么我们假设 struct NSObject_IMPL NSObject_IVARS; 等价于 Class isa; 可以将上述代码转化为 1struct Student_IMPL &#123;2 Class *isa;3 int _no;4 int _age;5&#125;; 因此此结构体占用多少存储空间，对象就占用多少存储空间。因此结构体占用的存储空间为，isa指针8个字节空间+int类型_no4个字节空间+int类型_age4个字节空间共16个字节空间 1Student *stu = [[Student alloc] init];2stu -&gt; _no = 4;3stu -&gt; _age = 5; 那么上述代码实际上在内存中的体现为，创建Student对象首先会分配16个字节，存储3个东西，isa指针8个字节，4个字节的_no ,4个字节的_age sutdent对象的3个变量分别有自己的地址。而stu指向isa指针的地址。因此stu的地址为0x100400110，stu对象在内存中占用16个字节的空间。并且经过赋值，_no里面存储4 ，_age里面存储5 验证Student在内存中模样 1struct Student_IMPL &#123;2 Class isa;3 int _no;4 int _age;5&#125;;67@interface Student : NSObject8&#123;9 @public10 int _no;11 int _age;12&#125;13@end1415@implementation Student1617int main(int argc, const char * argv[]) &#123;18 @autoreleasepool &#123;19 // 强制转化20 struct Student_IMPL *stuImpl = (__bridge struct Student_IMPL *)stu;21 NSLog(@\"_no = %d, _age = %d\", stuImpl-&gt;_no, stuImpl-&gt;_age); // 打印出 _no = 4, _age = 522 &#125;23 return 0;24&#125; 上述代码将oc对象强转成Student_IMPL的结构体。也就是说把一个指向oc对象的指针，指向这种结构体。由于我们之前猜想，对象在内存中的布局与结构体在内存中的布局相同，那么如果可以转化成功，说明我们的猜想正确。由此说明stu这个对象指向的内存确实是一个结构体。 实际上想要获取对象占用内存的大小，可以通过更便捷的运行时方法来获取。 1class_getInstanceSize([Student class])2NSLog(@\"%zd,%zd\", class_getInstanceSize([NSObject class]) ,class_getInstanceSize([Student class]));3// 打印信息 8和16 窥探内存结构实时查看内存数据 方式一：通过打断点。 Debug Workflow -&gt; viewMemory address中输入stu的地址 从上图中，我们可以发现读取数据从高位数据开始读，查看前16位字节，每四个字节读出的数据为 16进制 0x0000004(4字节) 0x0000005(4字节) isa的地址为 00D1081000001119(8字节) 方式二：通过lldb指令xcode自带的调试器 1memory read 0x10074c4502// 简写 x 0x10074c45034// 增加读取条件5// memory read/数量格式字节数 内存地址6// 简写 x/数量格式字节数 内存地址7// 格式 x是16进制，f是浮点，d是10进制8// 字节大小 b：byte 1字节，h：half word 2字节，w：word 4字节，g：giant word 8字节910示例：x/4xw // /后面表示如何读取数据 w表示4个字节4个字节读取，x表示以16进制的方式读取数据，4则表示读取4次 同时也可以通过lldb修改内存中的值 1memory write 0x100400c68 62将_no的值改为了6 那么一个NSObject对象占用多少内存？ NSObjcet实际上是只有一个名为isa的指针的结构体，因此占用一个指针变量所占用的内存空间大小，如果64bit占用8个字节，如果32bit占用4个字节。 更复杂的继承关系 面试题：在64bit环境下， 下面代码的输出内容？ 1/* Person */2@interface Person : NSObject3&#123;4 int _age;5&#125;6@end78@implementation Person9@end1011/* Student */12@interface Student : Person13&#123;14 int _no;15&#125;16@end1718@implementation Student19@end2021int main(int argc, const char * argv[]) &#123;22 @autoreleasepool &#123;2324 NSLog(@\"%zd %zd\",25 class_getInstanceSize([Person class]),26 class_getInstanceSize([Student class])27 );28 &#125;29 return 0;30&#125; 这道面试题的实质是想问一个Person对象，一个Student对象分别占用多少内存空间？ 我们依据上面的分析与发现，类对象实质上是以结构体的形式存储在内存中，画出真正的内存图例 我们发现只要是继承自NSObject的对象，那么底层结构体内一定有一个isa指针。 那么他们所占的内存空间是多少呢？单纯的将指针和成员变量所占的内存相加即可吗？上述代码实际打印的内容是16 16，也就是说，person对象和student对象所占用的内存空间都为16个字节。 其实实际上person对象确实只使用了12个字节。但是因为内存对齐的原因。使person对象也占用16个字节。 编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能是该基本数据类型的整倍的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为对齐模数。 为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。 我们可以总结内存对齐为两个原则： 原则 1. 前面的地址必须是后面的地址正数倍,不是就补齐。 原则 2. 整个Struct的地址必须是最大字节的整数倍。 通过上述内存对齐的原则我们来看，person对象的第一个地址要存放isa指针需要8个字节，第二个地址要存放_age成员变量需要4个字节，根据原则一，8是4的整数倍，符合原则一，不需要补齐。然后检查原则2，目前person对象共占据12个字节的内存，不是最大字节数8个字节的整数倍，所以需要补齐4个字节，因此person对象就占用16个字节空间。 而对于student对象，我们知道sutdent对象中，包含person对象的结构体实现，和一个int类型的_no成员变量，同样isa指针8个字节，_age成员变量4个字节，_no成员变量4个字节，刚好满足原则1和原则2，所以student对象占据的内存空间也是16个字节。 OC对象的分类 面试题：OC的类信息存放在哪里。 面试题：对象的isa指针指向哪里。 示例代码 1#import &lt;Foundation/Foundation.h&gt;2#import &lt;objc/runtime.h&gt;34/* Person */ 5@interface Person : NSObject &lt;NSCopying&gt;6&#123;7 @public8 int _age;9&#125;10@property (nonatomic, assign) int height;11- (void)personMethod;12+ (void)personClassMethod;13@end1415@implementation Person16- (void)personMethod &#123;&#125;17+ (void)personClassMethod &#123;&#125;18@end1920/* Student */21@interface Student : Person &lt;NSCoding&gt;22&#123;23 @public24 int _no;25&#125;26@property (nonatomic, assign) int score;27- (void)studentMethod;28+ (void)studentClassMethod;29@end3031@implementation Student32- (void)studentMethod &#123;&#125;33+ (void)studentClassMethod &#123;&#125;34@end3536int main(int argc, const char * argv[]) &#123;37 @autoreleasepool &#123; 38 NSObject *object1 = [[NSObject alloc] init];39 NSObject *object2 = [[NSObject alloc] init];4041 Student *stu = [[Student alloc] init];42 [Student load];4344 Person *p1 = [[Person alloc] init];45 p1-&gt;_age = 10;46 [p1 personMethod];47 [Person personClassMethod];48 Person *p2 = [[Person alloc] init];49 p2-&gt;_age = 20;50 &#125;51 return 0;52&#125; OC的类信息存放在哪里 OC对象主要可以分为三种 instance对象（实例对象） class对象（类对象） meta-class对象（元类对象） instance对象就是通过类alloc出来的对象，每次调用alloc都会产生新的instance对象 1NSObjcet *object1 = [[NSObjcet alloc] init];2NSObjcet *object2 = [[NSObjcet alloc] init]; object1和object2都是NSObject的instace对象（实例对象），但他们是不同的两个对象，并且分别占据着两块不同的内存。 instance对象在内存中存储的信息包括 isa指针 其他成员变量 衍生问题：在上图实例对象中根本没有看到方法，那么实例对象的方法的代码放在什么地方呢？那么类的方法的信息，协议的信息，属性的信息都存放在什么地方呢？ class对象 我们通过class方法或runtime方法得到一个class对象。class对象也就是类对象 1Class objectClass1 = [object1 class];2Class objectClass2 = [object2 class];3Class objectClass3 = [NSObject class];45// runtime6Class objectClass4 = object_getClass(object1);7Class objectClass5 = object_getClass(object2);8NSLog(@\"%p %p %p %p %p\", objectClass1, objectClass2, objectClass3, objectClass4, objectClass5); 每一个类在内存中有且只有一个class对象。可以通过打印内存地址证明 class对象在内存中存储的信息主要包括 isa指针 superclass指针 类的属性信息（@property），类的成员变量信息（ivar） 类的对象方法信息（instance method），类的协议信息（protocol） 成员变量的值时存储在实例对象中的，因为只有当我们创建实例对象的时候才为成员变赋值。但是成员变量叫什么名字，是什么类型，只需要有一份就可以了。所以存储在class对象中。 类方法放在那里？ 元类对象 meta-class 1//runtime中传入类对象此时得到的就是元类对象2Class objectMetaClass = object_getClass([NSObject class]);3// 而调用类对象的class方法时得到还是类对象，无论调用多少次都是类对象4Class cls = [[NSObject class] class];5Class objectClass3 = [NSObject class];6class_isMetaClass(objectMetaClass) // 判断该对象是否为元类对象7NSLog(@\"%p %p %p\", objectMetaClass, objectClass3, cls); // 后面两个地址相同，说明多次调用class得到的还是类对象 每个类在内存中有且只有一个meta-class对象。 meta-class对象和class对象的内存结构是一样的，但是用途不一样，在内存中存储的信息主要包括 isa指针 superclass指针 类的类方法的信息（class method） meta-class对象和class对象的内存结构是一样的，所以meta-class中也有类的属性信息，类的对象方法信息等成员变量，但是其中的值可能是空的。 对象的isa指针指向哪里 当对象调用实例方法的时候，我们上面讲到，实例方法信息是存储在class类对象中的，那么要想找到实例方法，就必须找到class类对象，那么此时isa的作用就来了。 1[stu studentMethod]; instance的isa指向class，当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现进行调用。 当类对象调用类方法的时候，同上，类方法是存储在meta-class元类对象中的。那么要找到类方法，就需要找到meta-class元类对象，而class类对象的isa指针就指向元类对象 1[Student studentClassMethod]; class的isa指向meta-class 当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用 当对象调用其父类对象方法的时候，又是怎么找到父类对象方法的呢？，此时就需要使用到class类对象superclass指针。 1[stu personMethod];2[stu init]; 当Student的instance对象要调用Person的对象方法时，会先通过isa找到Student的class，然后通过superclass找到Person的class，最后找到对象方法的实现进行调用，同样如果Person发现自己没有响应的对象方法，又会通过Person的superclass指针找到NSObject的class对象，去寻找响应的方法 当类对象调用父类的类方法时，就需要先通过isa指针找到meta-class，然后通过superclass去寻找响应的方法 1[Student personClassMethod];2[Student load]; 当Student的class要调用Person的类方法时，会先通过isa找到Student的meta-class，然后通过superclass找到Person的meta-class，最后找到类方法的实现进行调用 最后又是这张静定的isa指向图，经过上面的分析我们在来看这张图，就显得清晰明了很多。 对isa、superclass总结 instance的isa指向class class的isa指向meta-class meta-class的isa指向基类的meta-class，基类的isa指向自己 class的superclass指向父类的class，如果没有父类，superclass指针为nil meta-class的superclass指向父类的meta-class，基类的meta-class的superclass指向基类的class instance调用对象方法的轨迹，isa找到class，方法不存在，就通过superclass找父类 class调用类方法的轨迹，isa找meta-class，方法不存在，就通过superclass找父类 如何证明isa指针的指向真的如上面所说？我们通过如下代码证明： 1NSObject *object = [[NSObject alloc] init];2Class objectClass = [NSObject class];3Class objectMetaClass = object_getClass([NSObject class]);45NSLog(@\"%p %p %p\", object, objectClass, objectMetaClass); 打断点并通过控制台打印相应对象的isa指针 我们发现object-&gt;isa与objectClass的地址不同，这是因为从64bit开始，isa需要进行一次位运算，才能计算出真实地址。而位运算的值我们可以通过下载objc源代码找到。 我们通过位运算进行验证。 我们发现，object-isa指针地址0x001dffff96537141经过同0x00007ffffffffff8位运算，得出objectClass的地址0x00007fff96537140 接着我们来验证class对象的isa指针是否同样需要位运算计算出meta-class对象的地址。 当我们以同样的方式打印objectClass-&gt;isa指针时，发现无法打印 同时也发现左边objectClass对象中并没有isa指针。我们来到Class内部看一下 1typedef struct objc_class *Class;23struct objc_class &#123;4 Class _Nonnull isa OBJC_ISA_AVAILABILITY;56#if !__OBJC2__7 Class _Nullable super_class OBJC2_UNAVAILABLE;8 const char * _Nonnull name OBJC2_UNAVAILABLE;9 long version OBJC2_UNAVAILABLE;10 long info OBJC2_UNAVAILABLE;11 long instance_size OBJC2_UNAVAILABLE;12 struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE;13 struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE;14 struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE;15 struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;16#endif1718&#125; OBJC2_UNAVAILABLE;19/* Use `Class` instead of `struct objc_class *` */ 相信了解过isa指针的同学对objc_class结构体内的内容很熟悉了，今天这里不深入研究，我们只看第一个对象是一个isa指针，为了拿到isa指针的地址，我们自己创建一个同样的结构体并通过强制转化拿到isa指针。 1struct xx_cc_objc_class&#123;2 Class isa;3&#125;;45Class objectClass = [NSObject class];6struct xx_cc_objc_class *objectClass2 = (__bridge struct xx_cc_objc_class *)(objectClass); 此时我们重新验证一下 确实，objectClass2的isa指针经过位运算之后的地址是meta-class的地址。 本文总结： 一个NSObject对象占用多少内存？ 答：一个指针变量所占用的大小（64bit占8个字节，32bit占4个字节） 对象的isa指针指向哪里？ 答：instance对象的isa指针指向class对象，class对象的isa指针指向meta-class对象，meta-class对象的isa指针指向基类的meta-class对象，基类自己的isa指针也指向自己。 OC的类信息存放在哪里？ 答：成员变量的具体值存放在instance对象。对象方法，协议，属性，成员变量信息存放在class对象。类方法信息存放在meta-class对象。 底层原理相关文章：iOS底层原理总结 - 文集","categories":[{"name":"总结","slug":"总结","permalink":"https://bondiblue.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"OC","slug":"OC","permalink":"https://bondiblue.github.io/tags/OC/"}]}]}